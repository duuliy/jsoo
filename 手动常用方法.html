<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        //***********************实现一个new操作符***********************************/ 
        // 1.它创建了一个全新的对象。
        // 2.它会被执行 [[Prototype]]（也就是 __proto__）链接.
        // 3.它使 this指向新创建的对象，通过 new创建的每个对象将最终被 [[Prototype]]链接到这个函数的 prototype对象上。
        // 4.如果函数没有返回对象类型 Object(包含 Functoin,Array,Date,RegExg,Error)，那么 new表达式中的函数调用将返回该对象引用(返回this)。

        function New(func) {
            var res = {};
            if (func.prototype !== null) {
                res.__proto__ = func.prototype;
            }
            var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));
            if ((typeof ret === "object" || typeof ret === "function") && ret !== null) {
                return ret;
            }
            return res;
        }

        function Car(make) {
            this.make = make
            this.make2 = () => {

            }
        }

        const car1 = new Car('Eagle')
        const car2 = New(Car, 'Eagle')
        // console.log(car1)
        // console.log(car2)


        //***********************实现一个JSON.stringify***********************************/ 
        // 数组可以直接String(),如果里面没有对象，有对象才拼"{"

        function jsonStringify(obj) {
            let type = typeof obj;
            if (type !== "object" || type === null) {
                if (/string|undefined|function/.test(type)) {
                    obj = '"' + obj + '"';
                }
                return String(obj);
            } else {
                let json = []
                arr = (obj && obj.constructor === Array);
                for (let k in obj) {
                    let v = obj[k]; let type = typeof v;
                    if (/string|undefined|function/.test(type)) {
                        v = '"' + v + '"';
                    } else if (type === "object") {
                        v = jsonStringify(v);
                    }
                    json.push((arr ? "" : '"' + k + '":') + String(v));
                }
                return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}")
            }
        }
        jsonStringify({ x: 5 }) // "{"x":5}" 
        jsonStringify([1, "false", false]) // "[1,"false",false]" 
        jsonStringify({ b: undefined }) // "{"b":"undefined"}"


        //***********************实现一个JSON.parse***********************************/ 
        function jsonParse(opt) {
            return eval('(' + opt + ')');
        }
        jsonParse(jsonStringify({ x: 5 })) // Object { x: 5} 
        jsonParse(jsonStringify([1, "false", false])) // [1, "false", falsr] 
        jsonParse(jsonStringify({ b: undefined })) // Object { b: "undefined"}
        jsonParse("{ x: 5 }")  // Object { x: 5} 

        var jsonStr = '{ "age": 20, "name": "jack" }'
        var json = (new Function('return ' + jsonStr))()

        //***********************实现一个call或 apply***********************************/ 
        // Function.prototype  把对象转函数this

        Function.prototype.call2 = function (content = window) {
            content.fn = this;
            let args = [...arguments].slice(1);
            let result = content.fn(...args);
            delete content.fn;   //是否删除无所谓
            return result;
        }
        var foo = { value: 1 }
        function bar(name, age) {
            console.log(name)
            console.log(age)
            console.log(this.fn);
        }
        // bar.call2(foo, 'black', '18') // black 18 1

        Function.prototype.apply2 = function (context = window) {
            context.fn = this
            let result; // 判断是否有第二个参数 
            if (arguments[1]) {
                result = context.fn(...arguments[1])
            } else {
                result = context.fn()
            }
            delete context.fn()
            return result
        }


        //***********************实现一个Function.bind***********************************/ 
        // bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。
        // bind后并没有执行


        Function.prototype.bind2 = function (content) {
            const fn=this
            let args = [...arguments].slice(1);
            const wrpperFn= ()=>{
                fn.apply(content, args);
            }
            return wrpperFn;
        }
        var foo2 = { value: 2,value2: 3 }

        function bar2(name, age) {
            console.log(name)
            console.log(age)
            console.log(this.value2);
        }
        bar2.bind2(foo2,'duuliy',23)()


   //***********************实现一个继承***********************************/ 


   //***********************实现一个JS函数柯里化***********************************/ 


   //***********************手写一个Promise(中高级必考)***********************************/ 


   //***********************手写防抖(Debouncing)和节流(Throttling)***********************************/ 


   //***********************手写一个JS深拷贝***********************************/ 


   //***********************实现一个instanceOf***********************************/ 
    </script>
</body>

</html>