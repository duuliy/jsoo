<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 17. 电话号码的字母组合

    /**  回溯与递归
   * @param {string} digits 
   * @return {string[]}
   */

    //暴力即可
    var letterCombinations = function (digits) {
      let results = []
      const enume = {
        '2': ['a', 'b', 'c'],
        '3': ['d', 'e', 'f'],
        '4': ['g', 'h', 'i'],
        '5': ['j', 'k', 'l'],
        '6': ['m', 'n', 'o'],
        '7': ['p', 'q', 'r', 's'],
        '8': ['t', 'u', 'v'],
        '9': ['w', 'x', 'y', 'z'],
      }
      if (!digits) return results
      if (digits.length === 1) return enume[digits]
      const digitsArr = digits.split('').map(v => enume[v])
      const len = digitsArr.length

      const getCombination = (left, right) => {
        let res = []
        if (!left.length) return right
        for (let i = 0; i < left.length; i++) {
          for (let j = 0; j < right.length; j++) {
            res.push(left[i] + right[j])
          }
        }
        return res
      }

      for (let i = 0; i < len; i++) {
        results = results.concat(getCombination(results, digitsArr[i]))
      }

      return results.filter(v => v.length === len)
    }

    //回溯与递归
    var letterCombinations = function (digits) {
      let results = []
      const enume = {
        '2': ['a', 'b', 'c'],
        '3': ['d', 'e', 'f'],
        '4': ['g', 'h', 'i'],
        '5': ['j', 'k', 'l'],
        '6': ['m', 'n', 'o'],
        '7': ['p', 'q', 'r', 's'],
        '8': ['t', 'u', 'v'],
        '9': ['w', 'x', 'y', 'z'],
      }
      if (!digits) return results
      if (digits.length === 1) return enume[digits]
      const digitsArr = digits.split('').map(v => enume[v])
      const len = digitsArr.length

      const recursion = (arrs, res) => {
        let _res = []
        if (!res.length) res = arrs.shift()
        const arr = arrs.shift()

        for (let i = 0; i < res.length; i++) {
          for (let j = 0; j < arr.length; j++) {
            _res.push(res[i] + arr[j])
          }
        }
        if (!arrs.length) return results = _res
        else recursion(arrs, _res)
      }

      recursion(digitsArr, [])

      return results
    }

    // 120. 三角形最小路径和

    /**  动规 
   * @param {number[][]} triangle
   * @return {number}
   */

    // 自底向上，暴力遍历每位数，下层相连2位取小加本层i位（累计倒数第二层开始每i位符合的值），每层遍历后dp少一位，直到顶层只有一位。
    // 最小模型原则
    var minimumTotal = function (triangle) {
      let len = triangle.length
      if (!len) return 0
      const dp = triangle[len - 1]

      for (let i = len - 2; i >= 0; i--) {
        for (let j = 0; j < triangle[i].length; j++) {
          dp[j] = Math.min(dp[j], dp[j + 1]) + triangle[i][j]
        }
      }
      return dp[0]
    }


    //自上而下需要二维dp

    // 1027. 最长等差数列

    /**  动规
   * @param {number[]} nums
   * @return {number}
   */

    //1. 后一个减前一个得到差
    //2. 同样差的最多次数的等差数列

    //打debugger理解了代码能得到答案，不仅要差相等, 连起来还需要等差，画图找规律失败暂时放弃
    var longestArithSeqLength = function (nums) {
      let len = nums.length
      if (!len) return 0

      let max = 0
      let dp = new Array(len).fill(0).map(v => ({ 0: 0 })) //每个差出现的次数, 最小为0

      for (let i = len - 2; i >= 0; i--) {
        for (let j = i + 1; j < len; j++) {
          const diff = nums[j] - nums[i]   //j长度下有哪些差
          const diffLen = (dp[j][diff] || 0) + 1  //j长度下，相同的差个数（外循环增个数), 注意这个diff并没有赋值给dp！！！
          const maxIDiff = Math.max(dp[i][diff] || 0, diffLen)  //前一个dp[i]和的dp[j] j是i+1的递增 谁大
          dp[i][diff] = maxIDiff
          max = Math.max(max, maxIDiff)
        }
      }

      return max + 1 //2个差3个数
    }

    // 测试暴力双编辑得所有差值数量取最大跟以上dp时间差


    // 300. 最长递增子序列

    /**
   * @param {number[]} nums
   * @return {number}
   */

    //dp[0] = 1
    //dp[1] = 1, 2
    //dp[3] = 1,2,3,4
    //dp[i+1] = dp[i](不要nums[i]) 或 dp[i]+1 (要nums[i])
    //dp[i] = Math.max(dp[i], dp[j] + 1)  dp[j]取内循环中最大值
    // dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度 !!! (为什么要这么定义，划重点？目前没找到为什么，问就是子序列系列问题的一个套路公式)
    var lengthOfLIS = function (nums) {
      let len = nums.length
      if (!len) return 0
      const dp = []

      dp[0] = 1
      for (let i = 1; i < len; i++) {
        dp[i] = 1
        for (let j = 0; j < i; j++) {
          if (nums[i] > nums[j]) {
            dp[i] = Math.max(dp[i], dp[j] + 1)
          }
        }
      }

      return Math.max(...dp)
    }

    // 376. 摆动序列
    /**
   * @param {number[]} nums
   * @return {number}
   */

    // 1.连续正负差，1个或2个不相等 都算摆动
    // 2.包含0不算
    // 3.求最长子序
    // 不用动规，挺好
    var wiggleMaxLength = function (nums) {
      if (nums.length === 1) return 1

      let prediff = nums[1] - nums[0]
      let max = prediff === 0 ? 1 : 2

      for (let i = 1; i < nums.length - 1; i++) {
        const diff = nums[i + 1] - nums[i]
        if ((diff > 0 && prediff <= 0) || (diff < 0 && prediff >= 0)) {
          max++
          prediff = diff
        }
      }

      return max
    }

    // 1143. 最长公共子序列
    /**  动规
   * @param {string} text1
   * @param {string} text2
   * @return {number}
   */

    // 注意text1 和 text2 都可以删除字母
    //  以dp[i][j]结尾的的字符串网格公共子序列的个数
    // dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    var longestCommonSubsequence = function (text1, text2) {
      let len1 = text1.length
      let len2 = text2.length

      let dp = new Array(len1).fill(1).map(v => new Array(len2).fill(0))
      const helper = (i, j) => {
        if (i === len1 || j === len2) {
          return 0
        }

        if (dp[i][j] !== 0) {//减少遍历次数
          return dp[i][j]
        }

        if (text1.charAt(i) === text2.charAt(j)) {
          dp[i][j] = 1 + helper(i + 1, j + 1)
        } else {
          dp[i][j] = Math.max(
            helper(i + 1, j),
            helper(i, j + 1)
          )
        }
        return dp[i][j]
      }

      return helper(0, 0)
    }

    // 474. 一和零 (01背包变种)

    /** 动规
   * @param {string[]} strs
   * @param {number} m
   * @param {number} n
   * @return {number}
   */

    //套01背包写公式思路还是不难，但是做起来 ...TAT...
    //dp[i][j][s] 表示输入字符串在子区间 [0, s] 能够使用 i 个 0 和 j 个 1 的字符串的最大数量
    //动态转移方程：
    //   dp[i][j][k]= max(
    //     // 不选择当前字符串
    //     dp[i][j][k - 1],
    //     // 选择了当前字符串，用减掉可用个数后并且不能选择当前字符时的最优解
    //     dp[i - 当前字符使用 0 的个数][j - 当前字符使用 1 的个数][k - 1] 
    //   )
    var findMaxForm = function (strs, m, n) {
      let len = strs.length
      if (!len) return 0

      let dp = []
      function countMAndN(str) {
        let m = 0
        let n = 0
        for (let i = 0; i < str.length; i++) {
          if (str[i] === "0") {
            m++
          } else {
            n++
          }
        }
        return [m, n]
      }

      for (let i = 0; i <= m; i++) {
        dp[i] = []
        for (let j = 0; j <= n; j++) {
          dp[i][j] = []
          for (let s = 0; s < len; s++) {
            let str = strs[s]
            let [strM, strN] = countMAndN(str)

            let pickOnlyPrev = dp[i][j][s - 1] || 0  //不选择添加字符串
            let pickCurAndPrev = 0
            //选择添加字符串
            if (i >= strM && j >= strN) {
              pickCurAndPrev = 1 + (dp[i - strM][j - strN][s - 1] || 0)
            }

            dp[i][j][s] = Math.max(pickCurAndPrev, pickOnlyPrev)
          }
        }
      }
      return dp[m][n][len - 1]
    }

    // 494. 目标和
    /** 递归和回溯
   * @param {number[]} nums
   * @param {number} target
   * @return {number}
   */

    //用dp思路还是有点无厘头
    var findTargetSumWays = function (nums, target) {
      let len = nums.length - 1
      let result = 0

      const sum = (count, index) => {
        if (index === len) {
          if (count === target) result++
          return
        }
        index++
        sum(count - nums[index], index)
        sum(count + nums[index], index)
      }

      sum(nums[0], 0)
      sum(-nums[0], 0)

      return result
    }

    // 455. 分发饼干
    /**  双指针
   * @param {number[]} g
   * @param {number[]} s
   * @return {number}
   */

    //已是最优解
    var findContentChildren = function (g, s) {
      let result = 0
      let glen = g.length
      let slen = s.length
      const _g = g.sort((a, b) => a - b)
      const _s = s.sort((a, b) => a - b)
      let gIndex = 0
      let sIndex = 0

      while (gIndex < glen && sIndex < slen) {
        if (_s[sIndex] >= _g[gIndex]) {
          result++
          sIndex++
          gIndex++
        } else {
          sIndex++
        }
      }
      return result
    }

    // 435. 无重叠区间

    /**
   * @param {number[][]} intervals
   * @return {number}
   */
    var eraseOverlapIntervals = function (intervals) {
      let result = 0
      const isOverlap = (i, j) => {
        let [a, b] = intervals[i]
        let [c, d] = intervals[j]

        if (b > c || b > d) {
          let k = b > d ? i : j // 哪个区间大就删哪个, 由于排过序, 相等也删除的后面那个
          intervals.splice(k, 1)
          return true
        }

      }

      intervals.sort((a, b) => a[0] - b[0])
      for (let i = 0; i < intervals.length - 1; i++) {
        if (isOverlap(i, i + 1)) {
          result++
          i--
        }
      }

      return result
    }

    var eraseOverlapIntervals = function (intervals) {
      if (!intervals.length) {
        return 0;
      }

      intervals.sort((a, b) => a[1] - b[1]);

      const n = intervals.length;
      let right = intervals[0][1];
      let ans = 1;
      for (let i = 1; i < n; ++i) {
        if (intervals[i][0] >= right) {
          ++ans;
          right = intervals[i][1];
        }
      }
      return n - ans;
    }

    //  392. 判断子序列

    /** 双指针
   * @param {string} s
   * @param {string} t
   * @return {boolean}
   */
    //题目设定了t>s
    var isSubsequence = function (s, t) {
      let i = 0
      let j = 0

      while (i < s.length && j < t.length) {
        if (s[i] === t[j]) {
          i++
          j++
        } else {
          j++
        }
      }
      if (i === s.length) {
        return true
      } else {
        return false
      }
    }

    //进阶：t为map带index，循环s1，s2, s3....

    // 139. 单词拆分
    /** 动规和递归
   * @param {string} s 
   * @param {string[]} wordDict
   * @return {boolean}
   */

    //  "bb"
    //   ["a", "b", "bbb", "bbbb"]
    // 这题有点坑，这样是true，wordDict可以只用一部分。

    //超时但正确,等于全匹配，但是有重
    var wordBreak = (s, wordDict) => {
      const len = s.length
      const wordSet = new Set(wordDict);

      const canBreak = start => {
        if (start == len) {
          return true;
        }
        for (let i = start + 1; i <= len; i++) {
          const prefix = s.slice(start, i);
          if (wordSet.has(prefix) && canBreak(i)) {
            return true
          }
        }
        return false
      }

      return canBreak(0)
    }

    // dp[i]  ==> 0到i是否能被拆分
    // dp[i] = dp[j] && wordDict.has(s.substring(j, i)) ==> dp[j]为wordDict.has(s.substring(j, i)) 剩下的部分
    var wordBreak = function (s, wordDict) {
      let len = s.length
      if (!s || !len || !wordDict) return false
      wordSet = new Set(wordDict)
      const dp = []
      dp[0] = true
      for (let i = 1; i <= len; ++i) {
        for (let j = 0; j < i; ++j) {
          if (!!dp[j] && wordSet.has(s.substring(j, i))) {
            dp[i] = true;
            break;
          }
        }
      }
      return !!dp[len]
    }

    // 212. 单词搜索 II
    /**  递归和回溯
     * @param {character[][]} board
     * @param {string[]} words
     * @return {string[]}
     */

    //暴力
    var findWords = function (board, words) {
      const clen = board.length
      const rlen = board[0].length
      let results = new Set()

      const helper = (col, row, word, index) => {
        if (!word[index]) {
          results.add(word)
        }
        if (col < 0 || col >= clen || row < 0 || row >= rlen) {
          return
        }
        const target = board[col][row]
        if (target === word[index]) {
          board[col][row] = '-'
          helper(col + 1, row, word, index + 1)
          helper(col - 1, row, word, index + 1)
          helper(col, row + 1, word, index + 1)
          helper(col, row - 1, word, index + 1)
          board[col][row] = target
        }
      }

      const getInitCoord = word => {
        for (let i = 0; i < clen; i++) {
          for (let j = 0; j < rlen; j++) {
            if (board[i][j] === word[0]) {
              helper(i, j, word, 0)
            }
          }
        }
      }

      //看下面优化方案字典树优化在这里可以理解为是Map（实际开发中常用用于减少遍历），把多次的getInitCoord改成一次双遍历
      for (let i = 0; i < words.length; i++) {
        const word = words[i]
        const coord = getInitCoord(word)
      }

      return [...results]
    }

    //优化：前缀树把words装入，回溯board每个字母去前缀树对比，直到isEnd=true，加入res
    // 此方法主要节约了word中的 “前缀相同字母”的查找时间
    // 其实转换成map思路也可优化

    var findWords = (board, words) => {

      // 针对 board 中的每个字符，以它为起点向上下左右扩散，检查组成的字符是否在字典树中
      const dfs = (board, node, word, row, col, result) => {
        const dxy = [[-1, 0], [1, 0], [0, -1], [0, 1]]
        if (node.isEnd) result.add(word)
        let temp = board[row][col]
        board[row][col] = '@'
        for (const arr of dxy) {
          let _row = row + arr[0], _col = col + arr[1]
          if (_row >= 0 && _row < board.length && _col >= 0 && _col < board[0].length && node[board[_row][_col]] && board[_row][_col] !== '@') {
            dfs(board, node[board[_row][_col]], word + board[_row][_col], _row, _col, result)
          }
        }
        board[row][col] = temp
      }

      // 定义字典树(from Leetcode#208)
      class Trie {
        constructor() {
          this.root = {}
          this.isEnd = false
        }

        insert(word) {
          let node = this.root
          for (let i = 0; i < word.length; i++) {
            if (!node[word[i]]) node[word[i]] = {}
            node = node[word[i]]
          }
          node.isEnd = true
        }
      }

      if (!words.length || !board.length || !board[0].length) return []

      // 构造字典树，将words中的元素插入到字典树中
      const trie = new Trie()
      for (let str of words) trie.insert(str)

      // 遍历board列表，对每一个元素进行DFS
      const result = new Set()
      for (let row = 0; row < board.length; row++) {
        for (let col = 0; col < board[0].length; col++) {
          if (trie.root[board[row][col]]) dfs(board, trie.root[board[row][col]], board[row][col], row, col, result)
        }
      }
      return Array.from(result)
    }

    // 140. 单词拆分 II

    /**  递归和动规
   * @param {string} s
   * @param {string[]} wordDict
   * @return {string[]}
   */

    var wordBreak = (s, wordDict) => {
      const results = []
      const len = s.length
      const wordSet = new Set(wordDict);

      const canBreak = (start, result) => {
        if (start == len) {
          results.push(result.trim())
          return
        }
        for (let i = start + 1; i <= len; i++) {
          const prefix = s.slice(start, i);
          const boo = wordSet.has(prefix)
          if (wordSet.has(prefix)) {
            result += prefix + ' '
            canBreak(i, result)
            result = result.slice(0, -prefix.length - 1)
          }
        }
      }

      canBreak(0, '')
      return results
    }

    //动规
    var wordBreak = function (s, wordDict) {
      const uniq = (arr) => Array.from(new Set(arr))

      let uniqSChars = uniq(s.split(""))
      let uniqWordDictChars = uniq(wordDict.join(""))
      //去重s大于wordDict去重, 一定不能分割
      if (uniqSChars.length > uniqWordDictChars.length) return []

      const len = s.length
      const wordSet = new Set(wordDict);
      const dp = []
      dp[0] = ['']
      for (let i = 1; i <= len; ++i) {
        let res = []
        for (let j = 0; j < i; ++j) {
          const str = s.substring(j, i)
          const boo = wordSet.has(str)
          if (boo && dp[j] && dp[j].length) {
            for (let prev of dp[j]) {
              res.push(prev ? prev + " " + str : str)
            }
          }
        }
        dp[i] = res
      }
      return dp[len]
    }

    // 240. 搜索二维矩阵 II

    /**  双指针
   * @param {number[][]} matrix
   * @param {number} target
   * @return {boolean}
   */
    var searchMatrix = function (matrix, target) {
      const col = matrix.length - 1
      const row = matrix[0].length - 1

      const isBoo = rMatrix => {
        let rLeft = 0, rRight = row
        while (rLeft <= rRight) {
          if (rMatrix[rLeft] === target || rMatrix[rRight] === target) {
            return true
          } else {
            rLeft++
            rRight--
          }
        }
      }

      let cIndexArr = []
      for (let i = 0; i <= col; i++) {
        const rMatrix = matrix[i]
        if ((rMatrix[0] <= target) && (rMatrix[row] >= target)) {
          if (isBoo(rMatrix)) return true
        } else if (rMatrix[0] > target) {
          break
        }
      }

      return false
    }

    //优化
    var searchMatrix = function (matrix, target) {
      if (matrix === null || matrix.length === 0 || matrix[0].length === 0) return false;
      let col = 0;
      let row = matrix[0].length - 1;
      while (col < matrix.length && row >= 0) {
        if (matrix[col][row] > target) {
          row--;
        } else if (matrix[col][row] < target) {
          col++
        } else {
          return true;
        }
      }
      return false;
    };

    // 203. 移除链表元素

    /**  链表
   * @param {ListNode} head
   * @param {number} val
   * @return {ListNode}
   */

    var removeElements = function (head, val) {
      let virtual = {
        next: head
      }
      let current = virtual
      while (current) {
        if (current.next && current.next.val === val) {
          current.next = current.next.next
        } else {
          current = current.next
        }
      }

      return virtual.next
    }

    //递归
    var removeElements = function (head, val) {
        let ret = new ListNode(0, head)
        let current = ret
        const helper = (cur) => {
          if (!cur) return cur
          if (cur?.next?.val === val) {
            cur.next = cur.next.next
            helper(cur)
          } else {
            cur?.next && helper(cur.next)
          }
        }

        helper(current)
        return ret.next
      }

    // 524. 通过删除字母匹配到字典里最长单词
    /** 双指针
     * @param {string} s
     * @param {string[]} dictionary
     * @return {string}
     */

    var findLongestWord = function (s, dictionary) {
      let result = ''

      const isFindWord = str => {
        let sIndex = 0; strIndex = 0;

        while (s[sIndex]) {
          if (s[sIndex] === str[strIndex]) {
            sIndex++
            strIndex++
          } else {
            sIndex++
          }
        }
        return strIndex === str.length
      }

      for (let i = 0; i < dictionary.length; i++) {
        const str = dictionary[i]

        if (result.length > str.length) {
          continue
        }

        if (result.length === str.length && str > result) {
          continue
        }

        if (isFindWord(str)) {
          result = str
        }
      }
      return result
    }

    // 17.15.最长单词

    /** 动规
   * @param {string[]} words
   * @return {string}
   */
    var longestWord = function (words) {
      const wordBreak = (s, wordDict) => {
        let len = s.length
        if (!s || !len || !wordDict) return false
        wordSet = new Set(wordDict)
        const dp = []
        dp[0] = true;
        for (let i = 1; i <= len; ++i) {
          for (let j = 0; j < i; ++j) {
            if (!!dp[j] && wordSet.has(s.substring(j, i))) {
              dp[i] = true
              break
            }
          }
        }
        return !!dp[len]
      }

      words.sort((a, b) => {
        let diff = b.length - a.length
        if (diff !== 0) {
          return diff
        } else {
          return a < b ? -1 : 1
        }
      })
      for (let i = 0; i < words.length; i++) {
        let word = words[i]
        let rest = words.slice(0, i).concat(words.slice(i + 1))
        if (wordBreak(word, rest)) {
          return word
        }
      }
      return ''
    }

    // 1306. 跳跃游戏 III
    /**  bfs
     * @param {number[]} arr
     * @param {number} start
     * @return {boolean}
     */

    // 不用bfs数据大的让你超时,QAQ
    var canReach = function (arr, start) {
      let result = false
      let maxlen = arr.length

      const helper = (start, visited) => {
        visited[start] = true
        const indexVal = arr[start]
        if (indexVal === 0) {
          result = true
          return
        }

        const addVal = start + indexVal
        const deleteVal = start - indexVal

        if (addVal < maxlen && !visited[addVal]) helper(addVal, [...visited])
        if (deleteVal > -1 && !visited[deleteVal]) helper(deleteVal, [...visited])
        return
      }

      helper(start, [])
      return result
    }

    var canReach = function (arr, start) {
      let n = arr.length
      let visited = []
      let queue = [start]
      while (queue.length) {
        let index = queue.pop()
        let val = arr[index]
        if (val === 0) {
          return true
        }
        let left = index - val
        let right = index + val
        if (left >= 0 && !visited[left]) {
          queue.push(left)
        }
        if (right < n && !visited[right]) {
          queue.push(right)
        }
        visited[index] = true
      }
      return false
    }

    // 08.08 有重复字符串的排列组合

    /**  递归与回溯
   * @param {string} S
   * @return {string[]}
   */
    var permutation = function (S) {
      let results = []

      const helper = (prev, rest) => {
        if (prev.length === S.length) {
          res.push(prev)
          return
        }

        let visited = {}
        for (let i = 0; i < rest.length; i++) {
          let char = rest[i]
          if (visited[char]) {
            continue
          }
          visited[char] = true
          helper(prev + char, rest.substring(0, i) + rest.substring(i + 1))
        }
      }

      helper('', S)
      return results
    }

    // 221. 最大正方形

    /**  动规，找出方程比较难 QAQ
   * @param {character[][]} matrix
   * @return {number}
   */
    // 定义 dp[i][j]：以坐标(i, j) 为右下角的最大正方形边长。
    // (i, j) 为 0 时，无法构成正方形，dp[i][j] = 0
    // (i, j) 为 1 时，dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
    //  以面积为4的正方形去作为最小单位思考(画图): 
    // 一个正方形的最大边长决定于它左方、上方、斜上方的位置所能形成的最大正方形的边长，即：三者的最小值 + 1。
    // 然后把这个正方形缩小成2，继续与它左方、上方、斜上方的位置 去重复上一句话
    // 为了避免边界条件判断，可以将 dp 数组的长和宽都增加 1 !!!!!
    var maximalSquare = function (matrix) {
      let m = matrix.length
      let n = matrix[0].length
      const dp = new Array(m).fill(0).map(() => new Array(n).fill(0))
      let max = 0
      //处理边界
      for (let i = 0; i < m; i++) {
        if (matrix[i][0] === '1') {
          dp[i][0] = 1
          max = Math.max(max, dp[i][0])
        }

      }
      for (let j = 0; j < n; j++) {
        if (matrix[0][j] === '1') {
          dp[0][j] = 1
          max = Math.max(max, dp[0][j])
        }
      }
      for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
          if ((matrix[i][j] === '1')) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
            max = Math.max(max, dp[i][j])
            console.log(max)
          }
        }
      }
      return max * max
    }

    // 560. 和为K的子数组
    /**
   * @param {number[]} nums
   * @param {number} k
   * @return {number}
   */
    //超时
    var subarraySum = function (nums, k) {
      let result = 0
      let len = nums.length

      for (let i = 0; i < len; i++) {
        let count = 0
        for (let j = i; j < len; j++) {
          count += nums[j]
          if (count === k) {
            result++
          }
        }
      }

      return result
    }

    // 784. 字母大小写全排列
    /** 递归与回溯
   * @param {string} s
   * @return {string[]}
   */
    var letterCasePermutation = function (s) {
      const resluts = []
      const helper = (prev, rest) => {
        if (prev.length === s.length) {
          resluts.push(prev)
          return
        }
        let char = rest[0]
        const nextRest = rest.substring(1)
        if ((char - 0) == char) {
          helper(prev + char, nextRest)
        } else {
          const str = char.toUpperCase()
          const _str = char.toLowerCase()
          helper(prev + str, nextRest)
          helper(prev + _str, nextRest)
        }
      }

      helper('', s)
      return resluts
    }

    // 718. 最长重复子数组

    /** 动规比暴力难想,
     * 吃亏：数组子串不能includes
   * @param {number[]} nums1
   * @param {number[]} nums2
   * @return {number}
   */

    //暴力优化
    var findLength = function (nums1, nums2) {
      const len1 = nums1.length
      const len2 = nums2.length
      let max = 0

      const getMaxLength = (i, j, index) => {
        while (i + index < len1 && j + index < len2 && nums1[i + index] === nums2[j + index]) {
          index++
        }
        return index
      }

      for (let i = 0; i < len1; i++) {
        if (max > len1 - i) break; // 提前跳出
        for (let j = 0; j < len2; j++) {
          if (max > len2 - j) break; // 提前跳出
          if (nums1[i] === nums2[j]) {
            const _max = getMaxLength(i, j, 1)
            if (_max > max) max = _max
          }
        }
      }

      return max
    }

    //动规
    // dp[i][j] = dp[i + 1][j + 1] + 1 ,i和j起步往后数有多少位共有数组
    var findLength = function (nums1, nums2) {
      let dp = [], max = 0
      const len1 = nums1.length
      const len2 = nums2.length

      for (let i = 0; i <= len1; i++) {
        dp[i] = new Array(len2 + 1).fill(0);
      }

      for (let i = len1 - 1; i >= 0; i--) {
        for (let j = len2 - 1; j >= 0; j--) {
          if (nums1[i] === nums2[j]) {
            dp[i][j] = dp[i + 1][j + 1] + 1
            max = Math.max(max, dp[i][j])
          }
        }
      }

      return max
    }

    // 1219. 黄金矿工

    /**  回溯与递归
 * @param {number[][]} grid
 * @return {number}
 */
    //时间太多, 有点low，考虑cache.delete的形式做优化
    var getMaximumGold = function (grid) {
      const col = grid.length
      const row = grid[0].length
      let max = 0

      const isBoundary = (i, j) => !(i < 0 || i >= col || j < 0 || j >= row)

      const helper = (i, j, _max, cache) => {
        cache = new Map(cache)
        let isEnd = true
        _max += grid[i][j]
        cache.set(`${i}` + `${j}`, grid[i][j])

        if (isBoundary(i + 1, j) && !cache.get(`${i + 1}` + `${j}`) && grid[i + 1][j] !== 0) (isEnd = false, helper(i + 1, j, _max, [...cache]))
        if (isBoundary(i, j + 1) && !cache.get(`${i}` + `${j + 1}`) && grid[i][j + 1] !== 0) (isEnd = false, helper(i, j + 1, _max, [...cache]))
        if (isBoundary(i - 1, j) && !cache.get(`${i - 1}` + `${j}`) && grid[i - 1][j] !== 0) (isEnd = false, helper(i - 1, j, _max, [...cache]))
        if (isBoundary(i, j - 1) && !cache.get(`${i}` + `${j - 1}`) && grid[i][j - 1] !== 0) (isEnd = false, helper(i, j - 1, _max, [...cache]))

        if (isEnd && _max > max) max = _max
      }

      for (let i = 0; i < col; i++) {
        for (let j = 0; j < row; j++) {
          if (grid[i][j] !== 0) helper(i, j, 0, [])
        }
      }

      return max
    }

    //优化后
    var getMaximumGold = function (grid) {
      const col = grid.length
      const row = grid[0].length
      let max = 0

      const isBoundary = (i, j) => !(i < 0 || i >= col || j < 0 || j >= row) && grid[i][j] !== 0

      const helper = (i, j, _max) => {
        let isEnd = true, cache = grid[i][j]
        _max += cache
        grid[i][j] = 0

        if (isBoundary(i + 1, j)) (isEnd = false, helper(i + 1, j, _max))
        if (isBoundary(i, j + 1)) (isEnd = false, helper(i, j + 1, _max))
        if (isBoundary(i - 1, j)) (isEnd = false, helper(i - 1, j, _max))
        if (isBoundary(i, j - 1)) (isEnd = false, helper(i, j - 1, _max))
        grid[i][j] = cache

        if (isEnd && _max > max) max = _max
      }

      for (let i = 0; i < col; i++) {
        for (let j = 0; j < row; j++) {
          if (grid[i][j] !== 0) helper(i, j, 0)
        }
      }

      return max
    }

    // 62. 不同路径
    /**
   * @param {number} m
   * @param {number} n
   * @return {number}
   */

    //正确但超时
    var uniquePaths = function (m, n) {
      let result = 0

      const helper = (i, j) => {
        if (m === i && n === j) result++
        if (i < m) helper(i + 1, j)
        if (j < n) helper(i, j + 1)
      }

      helper(1, 1)
      return result
    }

    //画图： dp[m][n]=dp[i - 1][j] + dp[i][j - 1];
    var uniquePaths = function (m, n) {
      const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));
      for (let i = 0; i < m; i++) {
        dp[i][0] = 1;
      }
      for (let j = 0; j < n; j++) {
        dp[0][j] = 1;
      }
      for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
      }
      return dp[m - 1][n - 1]
    }

    // 980. 不同路径 III

    /**  回溯与递归
   * @param {number[][]} grid
   * @return {number}
   */
    var uniquePathsIII = function (grid) {
      let startI = 0
      let startJ = 0
      let totleZero = 0
      const col = grid.length
      const row = grid[0].length
      let max = 0

      for (let i = 0; i < col; i++) {
        for (let j = 0; j < row; j++) {
          if (grid[i][j] === 0) {
            ++totleZero
          }
          if (grid[i][j] === 1) {
            startI = i
            startJ = j
          }
        }
      }

      const isBoundary = (i, j) => !(i < 0 || i >= col || j < 0 || j >= row) && ![-1, 1].includes(grid[i][j])

      const helper = (i, j, totle) => {
        let isChange = false

        if (grid[i][j] === 2) {
          if (totleZero === totle) {
            max++
          }
          return
        }

        if (grid[i][j] === 0) {
          isChange = true
          totle++
          grid[i][j] = -1
        }

        if (isBoundary(i + 1, j)) helper(i + 1, j, totle)
        if (isBoundary(i, j + 1)) helper(i, j + 1, totle)
        if (isBoundary(i - 1, j)) helper(i - 1, j, totle)
        if (isBoundary(i, j - 1)) helper(i, j - 1, totle)
        isChange && (grid[i][j] = 0)
      }

      helper(startI, startJ, 0)

      return max
    }

    // 931. 下降路径最小和
    /**  动态规划
   * @param {number[][]} matrix
   * @return {number}
   */

    //dp[i][j] = matrix[i][j] + Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1])
    var minFallingPathSum = function (matrix) {
      const col = matrix.length
      const row = matrix[0].length
      const dp = new Array(col).fill(0).map(v => new Array(row).fill(Infinity))

      for (let j = 0; j < row; j++) {
        dp[0][j] = matrix[0][j]
      }

      for (let i = 1; i < col; i++) {
        for (let j = 0; j < row; j++) {
          if (j === 0) {
            dp[i][j] = matrix[i][j] + Math.min(dp[i - 1][j], dp[i - 1][j + 1])
          } else if (j === row - 1) {
            dp[i][j] = matrix[i][j] + Math.min(dp[i - 1][j - 1], dp[i - 1][j])
          } else {
            dp[i][j] = matrix[i][j] + Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1])
          }
        }
      }

      return Math.min(...dp[col - 1])
    }

    // 73. 矩阵置零
    /** 递归与回朔
   * @param {number[][]} matrix
   * @return {void} Do not return anything, modify matrix in-place instead.
   */

    //比用数组存位置和标记-1效率更高
    var setZeroes = function (matrix) {
      const col = matrix.length
      const row = matrix[0].length
      const zeroCol = new Array(col).fill(false)
      const zeroRow = new Array(row).fill(false)

      for (let i = 0; i < col; i++) {
        for (let j = 0; j < row; j++) {
          if (matrix[i][j] === 0) {
            zeroCol[i] = true
            zeroRow[j] = true
          }
        }
      }

      for (let i = 0; i < col; i++) {
        for (let j = 0; j < row; j++) {
          if (zeroCol[i] || zeroRow[j]) {
            matrix[i][j] = 0
          }
        }
      }

      return matrix
    }

    // 54. 螺旋矩阵

    /** 回溯与递归
   * @param {number[][]} matrix
   * @return {number[]}
   */

    //1.保存游过的所有位置。 2.上下左右找出空位·3.固定右下左上的顺序
    var spiralOrder = function (matrix) {
      let directIndex = 0
      let count = 0
      const col = matrix.length
      const row = matrix[0].length
      const total = col * row
      const result = []
      const oldMatrix = new Array(col).fill(0).map(v => new Array(row).fill(false))
      const isBoundary = (i, j) => !(i < 0 || i >= col || j < 0 || j >= row) && !oldMatrix[i][j]
      const direct = [
        [0, 1],
        [1, 0],
        [0, -1],
        [-1, 0]
      ]

      const helper = (i, j) => {
        count++
        oldMatrix[i][j] = true
        result.push(matrix[i][j])
        if (count === total) return
        const _i = i + direct[directIndex][0]
        const _j = j + direct[directIndex][1]
        if (!isBoundary(_i, _j)) {
          directIndex === 3 ? (directIndex = 0) : directIndex += 1
        }
        i = i + direct[directIndex][0]
        j = j + direct[directIndex][1]
        helper(i, j)
      }

      helper(0, 0)
      return result
    }

    // 59. 螺旋矩阵 II

    /** 回溯与递归
   * @param {number} n
   * @return {number[][]}
   */
    var generateMatrix = function (n) {
      let directIndex = 0
      let count = 0
      const total = n * n
      const matrix = new Array(n).fill(0).map(v => new Array(n).fill(0))
      const isBoundary = (i, j) => !(i < 0 || i >= n || j < 0 || j >= n) && !matrix[i][j]
      const direct = [
        [0, 1],
        [1, 0],
        [0, -1],
        [-1, 0]
      ]

      const helper = (i, j, num) => {
        matrix[i][j] = num

        if (num === total) return
        const _i = i + direct[directIndex][0]
        const _j = j + direct[directIndex][1]
        if (!isBoundary(_i, _j)) {
          directIndex === 3 ? (directIndex = 0) : directIndex += 1
        }
        i = i + direct[directIndex][0]
        j = j + direct[directIndex][1]
        helper(i, j, num += 1)
      }

      helper(0, 0, 1)
      return matrix
    }

    // 16. 最接近的三数之和
    /** 
   * @param {number[]} nums
   * @param {number} target
   * @return {number}
   */
    // 1.使遍历的第一位数固定，用双指针确定剩下的2位数。2.不断更新最小差值得出解决
    var threeSumClosest = function (nums, target) {
      let diffMin = Infinity
      let result
      nums.sort((a, b) => a - b)

      for (let i = 0; i < nums.length - 2; i++) {
        let left = i + 1, right = nums.length - 1

        while (right > left) {
          const totle = nums[left] + nums[right] + nums[i]
          const _diffMin = Math.abs(totle - target)
          if (_diffMin < diffMin) {
            diffMin = _diffMin
            result = totle
          }

          if (totle > target) {
            right--
          } else if (totle < target) {
            left++
          } else {
            return target
          }
        }
      }

      return result
    }

    // 1291. 顺次数
    /** 回溯与递归
   * @param {number} low
   * @param {number} high
   * @return {number[]}
   */
    //因为做了优化, 所以时间不长, 可以用'123456789', 滑动取值解题时间会更短
    var sequentialDigits = function (low, high) {
      const results = []
      const minDigit = String(low).length
      const maxDigit = String(high).length

      const helper = (freq) => {
        if (freq > maxDigit) return

        for (let i = 1; i <= 10 - freq; i++) {
          let str = String(i)
          let index = 1
          let j = i + 1
          while (index < freq) {
            index++
            str += String(j)
            j++
          }
          const num = Number(str)
          if (num > high) return
          if (num >= low && num <= high) results.push(num)
        }
        helper(freq += 1)
      }

      helper(minDigit)
      return results
    }

    // 873. 最长的斐波那契子序列的长度

    /**
     * @param {number[]} arr
     * @return {number}
     */

    // 暴力超时
    var lenLongestFibSubseq = function (arr) {
      let max = 0
      const len = arr.length
      for (let i = 0; i < len - 2; i++) {
        for (let j = i + 1; j < len - 1; j++) {
          let n1 = arr[i]
          let n2 = arr[j]
          let count = 0;
          let sum = n1 + n2;
          while (arr.includes(sum)) {
            n1 = n2;
            n2 = sum;
            sum = n1 + n2;
            count += 1
          }
          if (max < count) max = count
        }
      }
      return max < 1 ? 0 : max + 2
    }

    var lenLongestFibSubseq = function (arr) {
      const len = arr.length
      const dp = Array.from({ length: len }, () => new Array(len).fill(2))
      let res = 0

      for (let i = 1; i < len; i++) {
        for (let j = i + 1; j < len; j++) {
          for (let k = 0; k < i; k++) {
            if (arr[k] + arr[i] === arr[j]) {
              dp[i][j] = Math.max(dp[k][i] + 1, dp[i][j])
              res = Math.max(res, dp[i][j])
            }
          }
        }
      }
      return res
    }

    // 72. 编辑距离
    /** 困难
     * @param {string} word1
     * @param {string} word2
     * @return {number}
     */

    //完全根据题意全遍历，然后+增删替，操作原数据得爆.
    //转换思路，不完全根据题解，最后只求个数
    var minDistance = function (word1, word2) {
      const helper = (i, j) => {
        // 因为递归传入的是上一次的(i -1, j - 1)，所以这里都需要 + 1
        if (i === -1) return j + 1  // s1走完了，将s2剩下的插入s1,需要j + 1步
        if (j === -1) return i + 1 // s2走完了，删除s1剩下的，需要i + 1步
        if (word1[i] === word2[j]) {
          // 什么都不做，i,j向前移动一位
          return helper(i - 1, j - 1)
        } else {
          // 找出最小的
          return Math.min(
            helper(i, j - 1) + 1, // 插入，在word1[i]中插入和word2[j]一样的字符，相当于把word2向前移动1位，word1不动
            helper(i - 1, j) + 1, // 删除，把word1[i]删除，相当于word1向前移动1位,word2不动
            helper(i - 1, j - 1) + 1 // 替换操作，都向前移动1位
          )
        }
      }
      // 从后往前遍历，i, j 初始化指向最后一个索引
      return helper(word1.length - 1, word2.length - 1)
    }

    //储存优化
    var minDistance = function (word1, word2) {
      // 建一个字典
      const memo = new Map()
      const dp = (i, j) => {
        if (memo.has(i + '' + j)) return memo.get((i + '' + j))
        if (i === -1) return j + 1  // s1走完了，将s2剩下的插入s1,需要j + 1步
        if (j === -1) return i + 1 // s2走完了，删除s1剩下的，需要i + 1步
        if (word1[i] === word2[j]) {
          // 什么都不做，i,j向前移动一位
          memo.set(i + '' + j, dp(i - 1, j - 1))
        } else {
          memo.set(i + '' + j, Math.min(
            dp(i, j - 1) + 1, // 插入，在word1[i]中插入和word2[j]一样的字符，相当于把word2向前移动1位，word1不动
            dp(i - 1, j) + 1, // 删除，把word1[i]删除，相当于word1向前移动1位,word2不动
            dp(i - 1, j - 1) + 1 // 替换操作，都向前移动1位
          ))
        }
        return memo.get(i + '' + j)
      }
      // 从后往前遍历，i, j 初始化指向最后一个索引
      return dp(word1.length - 1, word2.length - 1)
    }

    //动规：dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。
    function minDistance(word1, word2) {
      const m = word1.length, n = word2.length;
      // 我们要多添加一行一列，用来做base case
      const dp = Array.from(Array(word1.length + 1), () => Array(word2.length + 1).fill(0));
      // 添加一列，base case
      for (let i = 1; i <= m; i++) {
        dp[i][0] = i;
      }
      // 添加一行，base case
      for (let i = 1; i <= n; i++) {
        dp[0][i] = i;
      }
      // 因为我们补了一行/列base case,这里都从1开始
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (word1[i - 1] === word2[j - 1]) { // 相等，什么都不做
            dp[i][j] = dp[i - 1][j - 1]
          } else {
            dp[i][j] = Math.min(
              dp[i - 1][j] + 1, // s1删除操作
              dp[i][j - 1] + 1, // s1插入操作
              dp[i - 1][j - 1] + 1 // 替换
            )
          }
        }
      }
      return dp[m][n]
    }


  </script>
</body>

</html>