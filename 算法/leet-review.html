<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 17. 电话号码的字母组合

    /**  回溯与递归
   * @param {string} digits 
   * @return {string[]}
   */

    //暴力
    var letterCombinations = function (digits) {
      let results = []
      const enume = {
        '2': ['a', 'b', 'c'],
        '3': ['d', 'e', 'f'],
        '4': ['g', 'h', 'i'],
        '5': ['j', 'k', 'l'],
        '6': ['m', 'n', 'o'],
        '7': ['p', 'q', 'r', 's'],
        '8': ['t', 'u', 'v'],
        '9': ['w', 'x', 'y', 'z'],
      }
      if (!digits) return results
      if (digits.length === 1) return enume[digits]
      const digitsArr = digits.split('').map(v => enume[v])
      const len = digitsArr.length

      const getCombination = (left, right) => {
        let res = []
        if (!left.length) return right
        for (let i = 0; i < left.length; i++) {
          for (let j = 0; j < right.length; j++) {
            res.push(left[i] + right[j])
          }
        }
        return res
      }

      for (let i = 0; i < len; i++) {
        results = results.concat(getCombination(results, digitsArr[i]))
      }

      return results.filter(v => v.length === len)
    }

    //回溯与递归
    var letterCombinations = function (digits) {
      let results = []
      const enume = {
        '2': ['a', 'b', 'c'],
        '3': ['d', 'e', 'f'],
        '4': ['g', 'h', 'i'],
        '5': ['j', 'k', 'l'],
        '6': ['m', 'n', 'o'],
        '7': ['p', 'q', 'r', 's'],
        '8': ['t', 'u', 'v'],
        '9': ['w', 'x', 'y', 'z'],
      }
      if (!digits) return results
      if (digits.length === 1) return enume[digits]
      const digitsArr = digits.split('').map(v => enume[v])
      const len = digitsArr.length

      const recursion = (arrs, res) => {
        let _res = []
        if (!res.length) res = arrs.shift()
        const arr = arrs.shift()

        for (let i = 0; i < res.length; i++) {
          for (let j = 0; j < arr.length; j++) {
            _res.push(res[i] + arr[j])
          }
        }
        if (!arrs.length) return results = _res
        else recursion(arrs, _res)
      }

      recursion(digitsArr, [])

      return results
    }

    // 120. 三角形最小路径和

    /**  动规 
   * @param {number[][]} triangle
   * @return {number}
   */

    // 自底向上，暴力遍历每位数，下层相连2位取小加本层i位（累计倒数第二层开始每i位符合的值），每层遍历后dp少一位，直到顶层只有一位。
    // 最小模型原则
    var minimumTotal = function (triangle) {
      let len = triangle.length
      if (!len) return 0
      const dp = triangle[len - 1]

      for (let i = len - 2; i >= 0; i--) {
        for (let j = 0; j < triangle[i].length; j++) {
          dp[j] = Math.min(dp[j], dp[j + 1]) + triangle[i][j]
        }
      }
      return dp[0]
    }

    // 1027. 最长等差数列

    /**  动规
   * @param {number[]} nums
   * @return {number}
   */

    //1. 后一个减前一个得到差
    //2. 同样差的最多次数的等差数列

    //打debugger理解了代码能得到答案，不仅要差相等, 连起来还需要等差，画图找规律失败暂时放弃
    var longestArithSeqLength = function (nums) {
      let len = nums.length
      if (!len) return 0

      let max = 0
      let dp = new Array(len).fill(0).map(v => ({ 0: 0 })) //每个差出现的次数, 最小为0

      for (let i = len - 2; i >= 0; i--) {
        for (let j = i + 1; j < len; j++) {
          const diff = nums[j] - nums[i]   //j长度下有哪些差
          const diffLen = (dp[j][diff] || 0) + 1  //j长度下，相同的差个数（外循环增个数), 注意这个diff并没有赋值给dp！！！
          const maxIDiff = Math.max(dp[i][diff] || 0, diffLen)  //前一个dp[i]和的dp[j] j是i+1的递增 谁大
          dp[i][diff] = maxIDiff
          max = Math.max(max, maxIDiff)
        }
      }

      return max + 1 //2个差3个数
    }


    // 300. 最长递增子序列

    /**
   * @param {number[]} nums
   * @return {number}
   */

    //dp[0] = 1
    //dp[1] = 1, 2
    //dp[3] = 1,2,3,4
    //dp[i+1] = dp[i](不要nums[i]) 或 dp[i]+1 (要nums[i])
    //dp[i] = Math.max(dp[i], dp[j] + 1)  dp[j]取内循环中最大值
    // dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
    var lengthOfLIS = function (nums) {
      let len = nums.length
      if (!len) return 0
      const dp = []

      dp[0] = 1
      for (let i = 1; i < len; i++) {
        dp[i] = 1
        for (let j = 0; j < i; j++) {
          if (nums[i] > nums[j]) {
            dp[i] = Math.max(dp[i], dp[j] + 1)
          }
        }
      }

      return Math.max(...dp)
    }

    // 376. 摆动序列
    /**
   * @param {number[]} nums
   * @return {number}
   */

    // 1.连续正负差，1个或2个不相等 都算摆动
    // 2.包含0不算
    // 3.求最长子序
    // 不必强用动规
    var wiggleMaxLength = function (nums) {
      if (nums.length === 1) return 1

      let prediff = nums[1] - nums[0]
      let max = prediff === 0 ? 1 : 2


      for (let i = 1; i < nums.length - 1; i++) {
        const diff = nums[i + 1] - nums[i]
        if ((diff > 0 && prediff <= 0) || (diff < 0 && prediff >= 0)) {
          max++
          prediff = diff
        }
      }

      return max
    }




  </script>
</body>

</html>