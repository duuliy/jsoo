<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 17. 电话号码的字母组合

    /**  回溯与递归
   * @param {string} digits 
   * @return {string[]}
   */

    //暴力
    var letterCombinations = function (digits) {
      let results = []
      const enume = {
        '2': ['a', 'b', 'c'],
        '3': ['d', 'e', 'f'],
        '4': ['g', 'h', 'i'],
        '5': ['j', 'k', 'l'],
        '6': ['m', 'n', 'o'],
        '7': ['p', 'q', 'r', 's'],
        '8': ['t', 'u', 'v'],
        '9': ['w', 'x', 'y', 'z'],
      }
      if (!digits) return results
      if (digits.length === 1) return enume[digits]
      const digitsArr = digits.split('').map(v => enume[v])
      const len = digitsArr.length

      const getCombination = (left, right) => {
        let res = []
        if (!left.length) return right
        for (let i = 0; i < left.length; i++) {
          for (let j = 0; j < right.length; j++) {
            res.push(left[i] + right[j])
          }
        }
        return res
      }

      for (let i = 0; i < len; i++) {
        results = results.concat(getCombination(results, digitsArr[i]))
      }

      return results.filter(v => v.length === len)
    }

    //回溯与递归
    var letterCombinations = function (digits) {
      let results = []
      const enume = {
        '2': ['a', 'b', 'c'],
        '3': ['d', 'e', 'f'],
        '4': ['g', 'h', 'i'],
        '5': ['j', 'k', 'l'],
        '6': ['m', 'n', 'o'],
        '7': ['p', 'q', 'r', 's'],
        '8': ['t', 'u', 'v'],
        '9': ['w', 'x', 'y', 'z'],
      }
      if (!digits) return results
      if (digits.length === 1) return enume[digits]
      const digitsArr = digits.split('').map(v => enume[v])
      const len = digitsArr.length

      const recursion = (arrs, res) => {
        let _res = []
        if (!res.length) res = arrs.shift()
        const arr = arrs.shift()

        for (let i = 0; i < res.length; i++) {
          for (let j = 0; j < arr.length; j++) {
            _res.push(res[i] + arr[j])
          }
        }
        if (!arrs.length) return results = _res
        else recursion(arrs, _res)
      }

      recursion(digitsArr, [])

      return results
    }

    // 120. 三角形最小路径和

    /**  动规 
   * @param {number[][]} triangle
   * @return {number}
   */

    // 自底向上，暴力遍历每位数，下层相连2位取小加本层i位（累计倒数第二层开始每i位符合的值），每层遍历后dp少一位，直到顶层只有一位。
    // 最小模型原则
    var minimumTotal = function (triangle) {
      let len = triangle.length
      if (!len) return 0
      const dp = triangle[len - 1]

      for (let i = len - 2; i >= 0; i--) {
        for (let j = 0; j < triangle[i].length; j++) {
          dp[j] = Math.min(dp[j], dp[j + 1]) + triangle[i][j]
        }
      }
      return dp[0]
    }

  </script>
</body>

</html>