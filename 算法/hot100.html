<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 15. 三数之和
    /**
   * @param {number[]} nums
   * @return {number[][]}
   */
    var threeSum = function (nums) {
      const len = nums.length, res = []
      if (nums == null || len < 3) return res
      nums.sort((a, b) => a - b)
      for (let i = 0; i < len; i++) {
        const cur = nums[i]
        if (cur > 0) break
        if (cur === nums[i - 1]) continue //去重
        let left = i + 1, right = len - 1

        while (left < right) {
          const sum = cur + nums[left] + nums[right]
          if (sum === 0) {
            res.push([cur, nums[left], nums[right]])
            while (left < right && nums[left] === nums[left + 1]) left++ //去重
            while (left < right && nums[right] === nums[right - 1]) right-- //去重
            left++, right--
          } else if (sum < 0) left++
          else if (sum > 0) right--
        }
      }
      return res
    }

    // 136. 只出现一次的数字
    /**
   * @param {number[]} nums
   * @return {number}
   */
    var singleNumber = function (nums) {
      let ans = 0
      for (let i = 0; i < nums.length; i++) {
        ans ^= nums[i]
      }
      return ans
    }

    // 33. 搜索旋转排序数组
    /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number}
   */
    //不用位运算的二分法,纯逻辑实现=>666
    var search = function (nums, target) {
      const len = nums.length
      if (!len) return -1
      let l = 0, r = len - 1

      while (r >= l) {
        const midIndex = Math.floor((l + r) / 2)
        if (nums[midIndex] === target) {
          return midIndex
        } else if (nums[l] === target) {
          return l
        } else if (nums[r] === target) {
          return r
        }

        if (nums[midIndex] > nums[l]) {
          if (target >= nums[l] && target < nums[midIndex]) { //确保nums没有值的时候 target >= nums[l] 下标进位
            r = midIndex - 1
          } else {
            l = midIndex + 1
          }
        } else {
          if (target > nums[midIndex] && target <= nums[r]) { //每次都以确定升序的一方的思路理解，来判定方向，否则亦然
            l = midIndex + 1
          } else {
            r = midIndex - 1
          }
        }
      }

      return -1
    }

    // 34. 在排序数组中查找元素的第一个和最后一个位置
    /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number}
   */

    /**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */

    //按道理需要二分法，但是不想搞位运算，所以偷懒了
    var searchRange = function (nums, target) {
      if (!nums.length) return [-1, -1]

      let res = []
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] === target) {
          res.push(i)
        }
      }

      if (res.length) {
        return [res[0], res[res.length - 1]]
      } else {
        return [-1, -1]
      }
    }

    // 面试题 08.04.幂集
    /**
   * @param {number[]} nums
   * @return {number[][]}
   */
    var subsets = function (nums) {
      const res = []

      const dfs = (path, index) => {
        res.push(path)
        for (let i = index; i < nums.length; i++) {
          dfs([...path, nums[i]], i + 1)
        }
      }

      dfs([], 0)
      return res
    }

    // 448. 找到所有数组中消失的数字

    /**
   * @param {number[]} nums
   * @return {number[]}
   */
    var findDisappearedNumbers = function (nums) {
      const res = []
      const len = nums.length
      const obj = {}

      for (let i = 0; i < len; i++) {
        obj[nums[i]] = true
      }

      for (let i = 1; i <= len; i++) {
        if (!obj[i]) res.push(i)
      }

      return res
    }

    // 94. 二叉树的中序遍历

    /**
   * @param {TreeNode} root
   * @return {number[]}
   */
    var inorderTraversal = function (root) {
      const res = []

      const helper = (node) => {
        if (!node) return void (0)
        node.left && helper(node.left)
        res.push(node.val)
        node.right && helper(node.right)
      }

      helper(root)
      return res
    }

    // 226. 翻转二叉树
    /**
   * @param {TreeNode} root
   * @return {TreeNode}
   */
    var invertTree = function (root) {
      if (!root) return null
      root.left && invertTree(root.left)
      root.right && invertTree(root.right);
      const lemp = root.right
      root.right = root.left
      root.left = lemp
      return root
    }

    // 169. 多数元素

    /**
   * @param {number[]} nums
   * @return {number}
   */
    var majorityElement = function (nums) {
      let count = 1
      const len = nums.length
      if (len === 1) return nums[0]
      const target = Math.floor(len / 2)
      nums.sort((a, b) => (a - b))

      for (let i = 1; i < len; i++) {
        if (nums[i - 1] === nums[i]) {
          count++
          if (count > target) return nums[i]
        } else {
          count = 1
        }
      }
    }

    // 543. 二叉树的直径
    /**
   * Definition for a binary tree node.
   * function TreeNode(val, left, right) {
   *     this.val = (val===undefined ? 0 : val)
   *     this.left = (left===undefined ? null : left)
   *     this.right = (right===undefined ? null : right)
   * }
   */
    /**
     * @param {TreeNode} root
     * @return {number}
     */
    //需要用dfs 去靠的思路解法
    var diameterOfBinaryTree = function (root) {
      let ans = 1
      const dfs = (node) => {
        if (!node) return 0
        let L = dfs(node.left)
        let R = dfs(node.right)
        ans = Math.max(ans, L + R + 1)
        return Math.max(L, R) + 1
      }
      dfs(root)
      return ans - 1 // 根据题意 -1
    }

    // 155. 最小栈
    var MinStack = function () {
      this.stack = [];
      this.min = []
      return this
    }

    /** 
     * @param {number} val
     * @return {void}
     */
    MinStack.prototype.push = function (val) {
      this.stack.unshift(val)
      if (!this.min.length) {
        this.min.unshift(val)
      } else {
        const min = Math.min(val, this.min[0])
        this.min.unshift(min)
      }
    }

    /**
     * @return {void}
     */
    MinStack.prototype.pop = function () {
      if (!this.stack.length) return void (0)
      this.stack.shift()
      this.min.shift()
    }

    /**
     * @return {number}
     */
    MinStack.prototype.top = function () {
      return this.stack[0]
    }

    /**
     * @return {number}
     */
    MinStack.prototype.getMin = function () {
      return this.min[0]
    }

    // 160. 相交链表
    /**
   * @param {ListNode} headA
   * @param {ListNode} headB
   * @return {ListNode}
   */
    var getIntersectionNode = function (headA, headB) {
      if (!headA || !headB) return null
      let mapA = new Map();
      while (headA) {
        mapA.set(headA, headA.val);
        headA = headA.next;
      }
      while (headB) {
        if (mapA.has(headB)) return headB
        headB = headB.next;
      }
      return null
    }





  </script>
</body>

</html>