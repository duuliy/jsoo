<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>中等</title>
</head>

<body>
  <script>
    // 144. 二叉树的前序遍历
    /**
   * @param {TreeNode} root
   * @return {number[]}
   */

    var preorderTraversal = function (root) {
      return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []
    };

    var preorderTraversal = function (root) {
      let result = [];
      let queue = [root];
      let node;
      while (node = queue.shift()) {
        result.push(node.val);

        node.right && queue.unshift(node.right);
        node.left && queue.unshift(node.left);
      }
      return result;
    };

    // 145. 二叉树的后序遍历
    /**
   * @param {TreeNode} root
   * @return {number[]}
   */
    var postorderTraversal = function (root) {
      return root ? [...postorderTraversal(root.left), ...postorderTraversal(root.right), root.val] : []
    };

    var postorderTraversal = function (root) {
      let result = [];
      let queue = [root];
      let node;
      while (node = queue.pop()) {
        result.unshift(node.val);

        node.left && queue.push(node.left);
        node.right && queue.push(node.right);

      }
      return result;
    };

    //3. 无重复字符的最长子串
    /**
 * @param {string} s
 * @return {number}
 */
    var lengthOfLongestSubstring = function (s) {
      let result = '';
      let maxLength = 0
      for (let i = 0; i < s.length; i++) {
        const index = result.indexOf(s[i])
        if (index === -1) {
          result += s[i]
          maxLength = maxLength < result.length ? result.length : maxLength
        } else {
          result = result.substr(index + 1) + s[i]
        }
      }
      return maxLength
    };

    // 2. 两数相加
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var addTwoNumbers = function (l1, l2) {
      let dummyHead = new ListNode(-1);
      let cur = dummyHead;
      let sum = 0;
      let carry = 0;
      while (l1 || l2) {
        sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry;
        carry = sum >= 10 ? 1 : 0
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        l1 && (l1 = l1.next);
        l2 && (l2 = l2.next);
      }
      carry && (cur.next = new ListNode(carry));
      return dummyHead.next;
    };


    //5.最长回文数
    /**
   * @param {string} s
   * @return {string}
   */
    //O(n*n*n)  很差 
    var longestPalindrome = function (s) {
      if (!s || s.length < 2) return s

      let sLength = s.length
      let maxStr = ''
      for (let i = 0; i < sLength; i++) {
        let endIndex = i
        let str = s[i]

        while (endIndex < sLength) {
          endIndex++
          str = s.substring(i, endIndex)
          if (isPalindrome(str)) {
            maxStr = maxStr.length >= str.length ? maxStr : str
          }
        }
      }

      return maxStr
    };

    function isPalindrome(str) {
      var len = str.length
      var middle = parseInt(len / 2)
      for (var i = 0; i < middle; i++) {
        if (str[i] != str[len - i - 1]) {
          return false
        }
      }
      return true
    }

    //11. 盛最多水的容器
    /**
   * @param {number[]} height
   * @return {number}
   */
    //超时
    var maxArea = function (height) {
      let area = 0
      height.forEach((v, i) => {
        height.forEach((k, j) => {
          let saveArea = Math.min(v, k) * (j - i)
          if (area < saveArea) area = saveArea
        })
      })
      return area
    };

    //快慢指针
    var maxArea = function (height) {
      let area = 0
      let i = 0
      let j = height.length - 1
      while (i !== j) {
        let saveArea = Math.min(height[i], height[j]) * (j - i)
        if (area < saveArea) area = saveArea
        if (height[i] > height[j]) {
          j--
        } else {
          i++
        }
      }
      return area
    };

  // 515. 在每个树行中找最大值
  /**
   * @param {TreeNode} root
   * @return {number[]}
   */

   var largestValues = function (root) {
      if (!root) return []
      let resultArr = []
      let queue = [root]

      while (queue.length) {
        let len = queue.length
        let max = Number.MIN_SAFE_INTEGER //万万没想到还有负值，这点确实坑
        for (let i = 0; i < len; i++) {
          const node = queue[i]
          if (node.val > max) { max = node.val }

          node.right && queue.push(node.right)
          node.left && queue.push(node.left)
        }
        resultArr.push(max)
        for (let i = 0; i < len; i++) {
          queue.shift()
        }
      }
      return resultArr
    }

  </script>
</body>

</html>