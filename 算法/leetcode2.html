<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>中等</title>
</head>

<body>
  <script>
    // 144. 二叉树的前序遍历
    /**
     * @param {TreeNode} root
     * @return {number[]}
     */

    var preorderTraversal = function (root) {
      return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []
    };

    var preorderTraversal = function (root) {
      let result = [];
      let queue = [root];
      let node;
      while (node = queue.shift()) {
        result.push(node.val);

        node.right && queue.unshift(node.right);
        node.left && queue.unshift(node.left);
      }
      return result;
    };

    // 145. 二叉树的后序遍历
    /**
     * @param {TreeNode} root
     * @return {number[]}
     */
    var postorderTraversal = function (root) {
      return root ? [...postorderTraversal(root.left), ...postorderTraversal(root.right), root.val] : []
    };

    var postorderTraversal = function (root) {
      let result = [];
      let queue = [root];
      let node;
      while (node = queue.pop()) {
        result.unshift(node.val);

        node.left && queue.push(node.left);
        node.right && queue.push(node.right);

      }
      return result;
    };

    //3. 无重复字符的最长子串
    /**
     * @param {string} s
     * @return {number}
     */
    var lengthOfLongestSubstring = function (s) {
      let result = '';
      let maxLength = 0
      for (let i = 0; i < s.length; i++) {
        const index = result.indexOf(s[i])
        if (index === -1) {
          result += s[i]
          maxLength = maxLength < result.length ? result.length : maxLength
        } else {
          result = result.substr(index + 1) + s[i]
        }
      }
      return maxLength
    };

    // 2. 两数相加
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var addTwoNumbers = function (l1, l2) {
      let dummyHead = new ListNode(-1);
      let cur = dummyHead;
      let sum = 0;
      let carry = 0;
      while (l1 || l2) {
        sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry;
        carry = sum >= 10 ? 1 : 0
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        l1 && (l1 = l1.next);
        l2 && (l2 = l2.next);
      }
      carry && (cur.next = new ListNode(carry));
      return dummyHead.next;
    };


    //5.最长回文数
    /**
     * @param {string} s
     * @return {string}
     */
    //O(n*n*n)  很差 
    var longestPalindrome = function (s) {
      if (!s || s.length < 2) return s

      let sLength = s.length
      let maxStr = ''
      for (let i = 0; i < sLength; i++) {
        let endIndex = i
        let str = s[i]

        while (endIndex < sLength) {
          endIndex++
          str = s.substring(i, endIndex)
          if (isPalindrome(str)) {
            maxStr = maxStr.length >= str.length ? maxStr : str
          }
        }
      }

      return maxStr
    };

    function isPalindrome(str) {
      var len = str.length
      var middle = parseInt(len / 2)
      for (var i = 0; i < middle; i++) {
        if (str[i] != str[len - i - 1]) {
          return false
        }
      }
      return true
    }

    //11. 盛最多水的容器
    /**
     * @param {number[]} height
     * @return {number}
     */
    //超时
    var maxArea = function (height) {
      let area = 0
      height.forEach((v, i) => {
        height.forEach((k, j) => {
          let saveArea = Math.min(v, k) * (j - i)
          if (area < saveArea) area = saveArea
        })
      })
      return area
    };

    //快慢指针
    var maxArea = function (height) {
      let area = 0
      let i = 0
      let j = height.length - 1
      while (i !== j) {
        let saveArea = Math.min(height[i], height[j]) * (j - i)
        if (area < saveArea) area = saveArea
        if (height[i] > height[j]) {
          j--
        } else {
          i++
        }
      }
      return area
    };

    // 515. 在每个树行中找最大值
    /**
     * @param {TreeNode} root
     * @return {number[]}
     */

    var largestValues = function (root) {
      if (!root) return []
      let resultArr = []
      let queue = [root]

      while (queue.length) {
        let len = queue.length
        let max = Number.MIN_SAFE_INTEGER //万万没想到还有负值，这点确实坑
        for (let i = 0; i < len; i++) {
          const node = queue[i]
          if (node.val > max) {
            max = node.val
          }

          node.right && queue.push(node.right)
          node.left && queue.push(node.left)
        }
        resultArr.push(max)
        for (let i = 0; i < len; i++) {
          queue.shift()
        }
      }
      return resultArr
    }


    // 695. 岛屿的最大面积
    /**
     * @param {number[][]} grid
     * @return {number}
     */
    var maxAreaOfIsland = function (grid) {
      let x = grid.length,
        y = grid[0].length
      let max = 0
      //关键点，上下左右的递归，不知道这点会相当折磨
      let countArea = (i, j) => {
        if (i < 0 || i >= x || j < 0 || j >= y || grid[i][j] == 0) return 0
        grid[i][j] = 0
        let count = 1
        count += countArea(i + 1, j)
        count += countArea(i - 1, j)
        count += countArea(i, j + 1)
        count += countArea(i, j - 1)
        return count
      }
      for (let i = 0; i < x; i++) {
        for (let j = 0; j < y; j++) {
          if (grid[i][j] == 1) max = Math.max(max, countArea(i, j))
        }
      }
      return max
    }

    // 442. 数组中重复的数据
    /**
     * @param {number[]} nums
     * @return {number[]}  有点坑，容易误解题意
     */
    var findDuplicates = function (nums) {
      let result = [];
      let newnums = nums.sort((a, b) => a - b);
      for (let i = 0; i < newnums.length - 1; i++) {
        if (newnums[i] == newnums[i + 1]) {
          result.push(newnums[i]);
        }
      }
      return result;
    };

    //343. 整数拆分
    /**
     * @param {number} n
     * @return {number}  动态规划
     */
    var integerBreak = function (n) {
      let arr = []
      arr[2] = 1
      arr[3] = 2
      arr[4] = 4
      arr[5] = 6
      arr[6] = 9

      let i = 7
      for (i; i <= n; i++) {
        arr[i] = arr[i - 3] * 3
      }

      return arr[n]
    };


    //130. 被围绕的区域
    /**  动态规划
     * @param {character[][]} board
     * @return {void} Do not return anything, modify board in-place instead.
     */
    var solve = function (board) {
      let m = board.length
      let n = board[0].length

      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if ((i === 0) || (i === m - 1) || (j === 0) || (j === n - 1) && board[i][j] === 'O') changeBoardImX(i, j)
        }
      }

      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (board[i][j] === -1) {
            board[i][j] = 'O'
          } else {
            board[i][j] = 'X'
          }
        }
      }

      function changeBoardImX(i, j) {
        if (i < 0 || j < 0 || i >= m || j >= n || board[i][j] === 'X' || board[i][j] === -1) return void (0)
        board[i][j] = -1
        changeBoardImX(i + 1, j)
        changeBoardImX(i - 1, j)
        changeBoardImX(i, j + 1)
        changeBoardImX(i, j - 1)
      }

      return board
    }


    // 198. 打家劫舍 提交很多次，打脑壳
    /**
     * @param {number} n
     * @return {number}
     */
    /**  动态规划
     * @param {number[]} nums
     * @return {number}
     */
    var rob = function (nums) {
      let len = nums.length
      let dp = [] //存储当前节点的最大值
      dp[0] = nums[0]
      dp[1] = Math.max(nums[0], nums[1])
      if (len === 1) {
        return dp[0]
      } else if (len === 2) {
        return dp[1]
      }
      for (let i = 2; i < len; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]) //最小单位的最大值：要么当前值+前2位的储存最大值，要么i-1的最大值
      }
      return dp[len - 1]
    }

    // 213. 打家劫舍 II 

    /** 动态规划
     * @param {number[]} nums
     * @return {number}
     * 
     */

    //形成环后增加边界情况，要么去头，要么掐尾
    var singleRob = function (nums) {
      let len = nums.length
      let dp = []
      dp[0] = nums[0]
      dp[1] = Math.max(nums[0], nums[1])
      for (let i = 2; i < len; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1])
      }
      return dp[len - 1]
    }
    var rob2 = function (nums) {
      let len = nums.length
      let dp = []
      dp[0] = nums[0]
      dp[1] = Math.max(nums[0], nums[1])
      if (len === 1) {
        return dp[0]
      } else if (len === 2) {
        return dp[1]
      }
      const nums1 = nums.slice(1, nums.length)
      const nums2 = nums.slice(0, nums.length - 1)

      return Math.max(singleRob(nums1), singleRob(nums2))
    }


    // 337. 打家劫舍 III

    /** 动态规划，这种题真的很难保证手写正确
     * @param {TreeNode} root
     * @return {number} 
     */

    //  1.本节点以及孙子
    //  2. 儿子
    //  3.left和 right 分开考虑
    // 虽然超时但是这可能是最好理解的思维方式,debugger看看，注意相互影响的递归就能理解
    var rob3 = function (root) {
      if (!root) {
        return 0;
      }

      let condition1 = root.val
      root.left && (condition1 += rob3(root.left.left) + rob3(root.left.right))
      root.right && (condition1 += rob3(root.right.left) + rob3(root.right.right))
      const condition2 = rob3(root.left) + rob3(root.right) //虽然没有返回但是每次递归到下一步取得是condition1的值赋给condition2

      return Math.max(condition2, condition1)
    }

    // const root={
    //   left:{
    //     right:{
    //       val:3
    //     },
    //     val:2
    //   },
    //   right:{ 
    //     right:{
    //       val:1
    //     },
    //     val:3
    //   },
    //   val:3
    // }
    // console.log(rob3(root))

    // 279. 完全平方数 动态转移方程
    /**
   * @param {number} n
   * @return {number}
   */

    // dp[1]=1  1
    // dp[2]=2  1+1
    // dp[3]=3  1+1+1

    // dp[i - j * j] + 1 推断过程如零钱，倒退
    // 最差情况dp[i]=i 全部为1 

    /**
   * @param {number} n
   * @return {number}
   */

    // 暴力子序和双循环试试
    // var numSquares = function (n) {
    //   let minLen = Infinity

    //   const recursion = (_n, len) => {
    //     // console.log(_n)
    //     for (let j = 1; j <=_n; j++) {
    //       if (_n > j * j&&Math.sqrt(j * j) % 1 === 0) {
    //         len+=1
    //         // console.log(j * j)
    //         recursion(_n - j*j, len)
    //       }
    //     }
    //     // console.log(666,len)
    //     return len
    //   }


    //   for (let i = 1; i <=n; i++) {
    //     // var len = 1;
    //     if (n > i * i &&Math.sqrt(i*i) % 1 === 0) {
    //       // console.log(n)
    //       console.log(i)
    //       let len = 1
    //       len = recursion(n - i * i, len)

    //       minLen = Math.min(minLen, len)
    //     }

    //   }

    //   return minLen
    // }


    var numSquares = function (n) {
      let dp = new Array(n + 1).fill(Infinity)
      dp[1] = 1
      dp[0] = 0

      for (let i = 1; i <= n; i++) {
        for (let j = 1; i - j * j >= 0; j++) {
          dp[i] = Math.min(dp[i], dp[i - j * j] + 1)
        }
      }

      return dp[n]
    }



    // console.log(numSquares(12))



    //322. 零钱兑换 
    /** 动态规划
   * @param {number[]} coins
   * @param {number} amount
   * @return {number}
   */

    //  dp[120] = Math.min(dp[119] + 1, dp[118] + 1, dp[115] + 1); coint=1,2,5
    // dp[i] = Math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...)
    const coinChange = (coins, amount) => {
      let dp = new Array(amount + 1).fill(Infinity)
      dp[0] = 0

      for (let coin of coins) {
        for (let i = coin; i <= amount; i++) {
          dp[i] = Math.min(dp[i], dp[i - coin] + 1)
        }
      }
      return dp[amount] === Infinity ? -1 : dp[amount]
    }

    //208. 实现 Trie (前缀树)  实际就是单向链表

    let TrieNode = function () {
      this.next = {}
      this.isEnd = false
    };

    /**
   * Initialize your data structure here.
   */
    var Trie = function () {
      this.root = new TrieNode()
    }

    /**
     * Inserts a word into the trie. 
     * @param {string} word
     * @return {void}
     */
    Trie.prototype.insert = function (word) {
      let node = this.root

      for (let i = 0; i < word.length; i++) {
        let { next } = node
        let trieNode = next[word[i]]
        if (!trieNode) {
          trieNode = new TrieNode()
          next[[word[i]]] = trieNode

        }
        node = trieNode

        if (i === word.length - 1) {
          node.isEnd = true
        }
      }
    }

    /**
     * Returns if the word is in the trie. 
     * @param {string} word
     * @return {boolean}
     */
    Trie.prototype.search = function (word) {
      let node = this.root

      for (let i = 0; i < word.length; i++) {
        let { next } = node
        let trieNode = next[word[i]]
        if (!trieNode) {
          return false
        }
        node = trieNode
      }
      return node.isEnd
    }

    /**
     * Returns if there is any word in the trie that starts with the given prefix. 
     * @param {string} prefix
     * @return {boolean}
     */
    Trie.prototype.startsWith = function (prefix) {
      let node = this.root

      for (let i = 0; i < prefix.length; i++) {
        let { next } = node
        let trieNode = next[prefix[i]]
        if (!trieNode) {
          return false
        }
        node = trieNode
      }
      return true
    }

    // const trie = new Trie()
    // trie.insert("apple")
    // trie.search("apple")
    // trie.startsWith("app")
    // console.log(trie)




  </script>
</body>

</html>