<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>中等</title>
</head>

<body>
  <script>
    // 144. 二叉树的前序遍历
    /** dfs
     * @param {TreeNode} root
     * @return {number[]}
     */

    var preorderTraversal = function (root) {
      return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []
    };

    var preorderTraversal = function (root) {
      let result = [];
      let queue = [root];
      let node;
      while (node = queue.shift()) {
        result.push(node.val);

        node.right && queue.unshift(node.right);
        node.left && queue.unshift(node.left);
      }
      return result;
    };

    // 145. 二叉树的后序遍历
    /** dfs
     * @param {TreeNode} root
     * @return {number[]}
     */
    var postorderTraversal = function (root) {
      return root ? [...postorderTraversal(root.left), ...postorderTraversal(root.right), root.val] : []
    };

    var postorderTraversal = function (root) {
      let result = [];
      let queue = [root];
      let node;
      while (node = queue.pop()) {
        result.unshift(node.val);

        node.left && queue.push(node.left);
        node.right && queue.push(node.right);

      }
      return result;
    };

    //3. 无重复字符的最长子串
    /**
     * @param {string} s
     * @return {number}
     */
    var lengthOfLongestSubstring = function (s) {
      let result = '';
      let maxLength = 0
      for (let i = 0; i < s.length; i++) {
        const index = result.indexOf(s[i])
        if (index === -1) {
          result += s[i]
          maxLength = maxLength < result.length ? result.length : maxLength
        } else {
          result = result.substr(index + 1) + s[i]
        }
      }
      return maxLength
    }

    // 2. 两数相加
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var addTwoNumbers = function (l1, l2) {
      let dummyHead = new ListNode(-1);
      let cur = dummyHead;
      let sum = 0;
      let carry = 0;
      while (l1 || l2) {
        sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry;
        carry = sum >= 10 ? 1 : 0
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        l1 && (l1 = l1.next);
        l2 && (l2 = l2.next);
      }
      carry && (cur.next = new ListNode(carry));
      return dummyHead.next;
    };


    //5.最长回文子串
    /**
     * @param {string} s
     * @return {string}
     */
    //O(n*n*n)  很差 
    var longestPalindrome = function (s) {
      if (!s || s.length < 2) return s

      let sLength = s.length
      let maxStr = ''
      for (let i = 0; i < sLength; i++) {
        let endIndex = i
        let str = s[i]

        while (endIndex < sLength) {
          endIndex++
          str = s.substring(i, endIndex)
          if (isPalindrome(str)) {
            maxStr = maxStr.length >= str.length ? maxStr : str
          }
        }
      }

      return maxStr
    }

    function isPalindrome(str) {
      var len = str.length
      var middle = parseInt(len / 2)
      for (var i = 0; i < middle; i++) {
        if (str[i] != str[len - i - 1]) {
          return false
        }
      }
      return true
    }

    //11. 盛最多水的容器
    /**
     * @param {number[]} height
     * @return {number}
     */
    //超时
    var maxArea = function (height) {
      let area = 0
      height.forEach((v, i) => {
        height.forEach((k, j) => {
          let saveArea = Math.min(v, k) * (j - i)
          if (area < saveArea) area = saveArea
        })
      })
      return area
    };

    //快慢指针
    var maxArea = function (height) {
      let area = 0
      let i = 0
      let j = height.length - 1
      while (i !== j) {
        let saveArea = Math.min(height[i], height[j]) * (j - i)
        if (area < saveArea) area = saveArea
        if (height[i] > height[j]) {
          j--
        } else {
          i++
        }
      }
      return area
    };

    // 515. 在每个树行中找最大值
    /**
     * @param {TreeNode} root
     * @return {number[]}
     */

    var largestValues = function (root) {
      if (!root) return []
      let resultArr = []
      let queue = [root]

      while (queue.length) {
        let len = queue.length
        let max = Number.MIN_SAFE_INTEGER //万万没想到还有负值，这点确实坑
        for (let i = 0; i < len; i++) {
          const node = queue[i]
          if (node.val > max) {
            max = node.val
          }

          node.right && queue.push(node.right)
          node.left && queue.push(node.left)
        }
        resultArr.push(max)
        for (let i = 0; i < len; i++) {
          queue.shift()
        }
      }
      return resultArr
    }


    // 695. 岛屿的最大面积
    /**
     * @param {number[][]} grid
     * @return {number}
     */
    var maxAreaOfIsland = function (grid) {
      let x = grid.length,
        y = grid[0].length
      let max = 0
      //关键点，上下左右的递归，不知道这点会相当折磨
      let countArea = (i, j) => {
        if (i < 0 || i >= x || j < 0 || j >= y || grid[i][j] == 0) return 0
        grid[i][j] = 0
        let count = 1
        count += countArea(i + 1, j)
        count += countArea(i - 1, j)
        count += countArea(i, j + 1)
        count += countArea(i, j - 1)
        return count
      }
      for (let i = 0; i < x; i++) {
        for (let j = 0; j < y; j++) {
          if (grid[i][j] == 1) max = Math.max(max, countArea(i, j))
        }
      }
      return max
    }

    // 442. 数组中重复的数据
    /**
     * @param {number[]} nums
     * @return {number[]}  有点坑，容易误解题意
     */
    var findDuplicates = function (nums) {
      let result = [];
      let newnums = nums.sort((a, b) => a - b);
      for (let i = 0; i < newnums.length - 1; i++) {
        if (newnums[i] == newnums[i + 1]) {
          result.push(newnums[i]);
        }
      }
      return result;
    };

    //343. 整数拆分
    /**
     * @param {number} n
     * @return {number}  动规
     */
    var integerBreak = function (n) {
      let arr = []
      arr[2] = 1
      arr[3] = 2
      arr[4] = 4
      arr[5] = 6
      arr[6] = 9

      let i = 7
      for (i; i <= n; i++) {
        arr[i] = arr[i - 3] * 3
      }

      return arr[n]
    };


    //130. 被围绕的区域
    /** 
     * @param {character[][]} board
     * @return {void} Do not return anything, modify board in-place instead.
     */
    var solve = function (board) {
      let m = board.length
      let n = board[0].length

      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if ((i === 0) || (i === m - 1) || (j === 0) || (j === n - 1) && board[i][j] === 'O') changeBoardImX(i, j)
        }
      }

      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (board[i][j] === -1) {
            board[i][j] = 'O'
          } else {
            board[i][j] = 'X'
          }
        }
      }

      function changeBoardImX(i, j) {
        if (i < 0 || j < 0 || i >= m || j >= n || board[i][j] === 'X' || board[i][j] === -1) return void (0)
        board[i][j] = -1
        changeBoardImX(i + 1, j)
        changeBoardImX(i - 1, j)
        changeBoardImX(i, j + 1)
        changeBoardImX(i, j - 1)
      }

      return board
    }


    // 198. 打家劫舍
    /**  动规
     * @param {number[]} nums
     * @return {number}
     */
    var rob = function (nums) {
      let len = nums.length
      let dp = [] //存储当前节点的最大值
      dp[0] = nums[0]
      dp[1] = Math.max(nums[0], nums[1])
      if (len === 1) {
        return dp[0]
      } else if (len === 2) {
        return dp[1]
      }
      for (let i = 2; i < len; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]) //最小单位的最大值：要么当前值+前2位的储存最大值，要么i-1的最大值
      }
      return dp[len - 1]
    }

    // 213. 打家劫舍 II 

    /** 动规
     * @param {number[]} nums
     * @return {number}
     * 
     */

    //形成环后增加边界情况，要么去头，要么掐尾
    var singleRob = function (nums) {
      let len = nums.length
      let dp = []
      dp[0] = nums[0]
      dp[1] = Math.max(nums[0], nums[1])
      for (let i = 2; i < len; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1])
      }
      return dp[len - 1]
    }
    var rob2 = function (nums) {
      let len = nums.length
      let dp = []
      dp[0] = nums[0]
      dp[1] = Math.max(nums[0], nums[1])
      if (len === 1) {
        return dp[0]
      } else if (len === 2) {
        return dp[1]
      }
      const nums1 = nums.slice(1, nums.length)
      const nums2 = nums.slice(0, nums.length - 1)

      return Math.max(singleRob(nums1), singleRob(nums2))
    }


    // 337. 打家劫舍 III

    /** 动规，这种题真的很难保证手写正确
     * @param {TreeNode} root
     * @return {number} 
     */

    //  1.本节点以及孙子
    //  2. 儿子
    //  3.left和 right 分开考虑
    // 虽然超时但是这可能是最好理解的思维方式,debugger看看，注意相互影响的递归就能理解
    var rob3 = function (root) {
      if (!root) {
        return 0;
      }

      let condition1 = root.val
      root.left && (condition1 += rob3(root.left.left) + rob3(root.left.right))
      root.right && (condition1 += rob3(root.right.left) + rob3(root.right.right))
      const condition2 = rob3(root.left) + rob3(root.right) //虽然没有返回但是每次递归到下一步取得是condition1的值赋给condition2

      return Math.max(condition2, condition1)
    }

    // const root={
    //   left:{
    //     right:{
    //       val:3
    //     },
    //     val:2
    //   },
    //   right:{ 
    //     right:{
    //       val:1
    //     },
    //     val:3
    //   },
    //   val:3
    // }
    // console.log(rob3(root))

    // 279. 完全平方数 动态转移方程
    /**
   * @param {number} n
   * @return {number}
   */

    // dp[1]=1  1
    // dp[2]=2  1+1
    // dp[3]=3  1+1+1

    // dp[i - j * j] + 1 推断过程如零钱，倒退
    // 最差情况dp[i]=i 全部为1 

    /**
   * @param {number} n
   * @return {number}
   */

    // 暴力子序和双循环试试
    // var numSquares = function (n) {
    //   let minLen = Infinity

    //   const recursion = (_n, len) => {
    //     // console.log(_n)
    //     for (let j = 1; j <=_n; j++) {
    //       if (_n > j * j&&Math.sqrt(j * j) % 1 === 0) {
    //         len+=1
    //         // console.log(j * j)
    //         recursion(_n - j*j, len)
    //       }
    //     }
    //     // console.log(666,len)
    //     return len
    //   }


    //   for (let i = 1; i <=n; i++) {
    //     // var len = 1;
    //     if (n > i * i &&Math.sqrt(i*i) % 1 === 0) {
    //       // console.log(n)
    //       console.log(i)
    //       let len = 1
    //       len = recursion(n - i * i, len)

    //       minLen = Math.min(minLen, len)
    //     }

    //   }

    //   return minLen
    // }


    var numSquares = function (n) {
      let dp = new Array(n + 1).fill(Infinity)
      dp[1] = 1
      dp[0] = 0

      for (let i = 1; i <= n; i++) {
        for (let j = 1; i - j * j >= 0; j++) {
          dp[i] = Math.min(dp[i], dp[i - j * j] + 1)
        }
      }

      return dp[n]
    }



    // console.log(numSquares(12))



    //322. 零钱兑换 
    /** 动规
   * @param {number[]} coins
   * @param {number} amount
   * @return {number}
   */

    //  dp[120] = Math.min(dp[119] + 1, dp[118] + 1, dp[115] + 1); coint=1,2,5
    // dp[i] = Math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...)
    var coinChange = (coins, amount) => {
      let dp = new Array(amount + 1).fill(Infinity)
      dp[0] = 0

      for (let coin of coins) {
        for (let i = coin; i <= amount; i++) {
          dp[i] = Math.min(dp[i], dp[i - coin] + 1)
        }
      }
      return dp[amount] === Infinity ? -1 : dp[amount]
    }

    //更易理解
    var coinChange = function (coins, amount) {
      let dp = new Array(amount + 1).fill(Infinity);
      dp[0] = 0;

      for (let i = 1; i <= amount; i++) {
        for (let coin of coins) {
          if (i - coin >= 0) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
          }
        }
      }

      return dp[amount] === Infinity ? -1 : dp[amount];
    };

    //208. 实现 Trie (前缀树)  实际就是单向链表

    let TrieNode = function () {
      this.next = {}
      this.isEnd = false
    };

    /**
   * Initialize your data structure here.
   */
    var Trie = function () {
      this.root = new TrieNode()
    }

    /**
     * Inserts a word into the trie. 
     * @param {string} word
     * @return {void}
     */
    Trie.prototype.insert = function (word) {
      let node = this.root

      for (let i = 0; i < word.length; i++) {
        let { next } = node
        let trieNode = next[word[i]]
        if (!trieNode) {
          trieNode = new TrieNode()
          next[[word[i]]] = trieNode

        }
        node = trieNode

        if (i === word.length - 1) {
          node.isEnd = true
        }
      }
    }

    /**
     * Returns if the word is in the trie. 
     * @param {string} word
     * @return {boolean}
     */
    Trie.prototype.search = function (word) {
      let node = this.root

      for (let i = 0; i < word.length; i++) {
        let { next } = node
        let trieNode = next[word[i]]
        if (!trieNode) {
          return false
        }
        node = trieNode
      }
      return node.isEnd
    }

    /**
     * Returns if there is any word in the trie that starts with the given prefix. 
     * @param {string} prefix
     * @return {boolean}
     */
    Trie.prototype.startsWith = function (prefix) {
      let node = this.root

      for (let i = 0; i < prefix.length; i++) {
        let { next } = node
        let trieNode = next[prefix[i]]
        if (!trieNode) {
          return false
        }
        node = trieNode
      }
      return true
    }

    // const trie = new Trie()
    // trie.insert("apple")
    // trie.search("apple")
    // trie.startsWith("app")
    // console.log(trie)


    // 152. 乘积最大子数组
    /**
   * @param {number[]} nums
   * @return {number}
   */

    //中等难度肯定超时，但是思路最简单
    var maxProduct = function (nums) {
      let len = nums.length
      let max = 0

      for (let i = 0; i < len; i++) {
        let totalNum = nums[i]
        for (let j = i + 1; j < len; j++) {
          totalNum *= nums[j]
          max = Math.max(max, totalNum)
        }
      }

      return max
    }

    //dp[i]=Math.max(nums[i],dp[i-1]*nums[i]) 若没有负负的正的情况
    //包含正负：正不变，负的最大值是负的最多的，但是下一位是负的话，乘积为为最大值
    //记录上一次的最大和最小值，乘当前值=>要么最大正或最大负，不然就是0

    var maxProduct = function (nums) {
      let len = nums.length
      let dp = []
      dp[0] = nums[0]
      let prevMin = nums[0]
      let prevMax = nums[0]
      let temp1 = 0, temp2 = 0

      for (let i = 1; i < len; i++) {
        temp1 = prevMin * nums[i]
        temp2 = prevMax * nums[i]
        prevMin = Math.min(temp1, temp2, nums[i])
        prevMax = Math.max(temp1, temp2, nums[i])
        dp[i] = Math.max(dp[i - 1], prevMax)
      }

      return Math.max(...dp)
    }

    // console.log(maxProduct([-2, 0, -1]))


    // 113. 路径总和 II
    /**
   * @param {TreeNode} root
   * @param {number} targetSum
   * @return {number[][]}
   */

    var pathSum = function (root, targetSum) {
      let queue = []
      let results = []

      const recursion = (node, result) => {
        if (!node) return
        result.push(node.val)

        if (!node.right && !node.left) {
          if (result.reduce((totle, v) => totle + v) === targetSum) results.push(result)
        } else {
          node.left && recursion(node.left, [...result])
          node.right && recursion(node.right, [...result])
        }
      }

      recursion(root, [])
      return results
    }

    // 75. 颜色分类

    /**
   * @param {number[]} nums
   * @return {void} Do not return anything, modify nums in-place instead.
   */
    var sortColors = function (nums) {
      return nums.sort()
    }

    var sortColors = function (nums) {
      let redIndex = 0
      let blueIndex = 0

      for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 0) {
          nums.splice(i, 1)
          i--
          redIndex += 1
        } else if (nums[i] === 2) {
          nums.splice(i, 1)
          i--
          blueIndex += 1
        }
      }

      for (let i = 0; i < redIndex; i++) {
        nums.unshift(0)
      }

      for (let i = 0; i < blueIndex; i++) {
        nums.push(2)
      }

      return nums
    }

    // 102. 二叉树的层序遍历

    /** bfs
   * @param {TreeNode} root
   * @return {number[][]}
   */
    var levelOrder = function (root) {
      if (!root) return []
      let queue = [root]
      let results = []

      while (queue.length) {
        const len = queue.length
        let result = []

        for (let i = 0; i < len; i++) {
          const node = queue.shift()
          result.push(node.val)
          node.left && queue.push(node.left)
          node.right && queue.push(node.right)
        }

        results.push(result)
      }
      return results
    }

    // 22. 括号生成

    /** 回溯，多种条件，积累所有情况。。。函数内可以写多不同条件递归!
   * @param {number} n
   * @return {string[]}
   */
    // start,end 左右括号的数量
    // 保证不能以"）"开始的括号 start > end
    var generateParenthesis = function (n) {
      let results = []

      const recursion = (start, end, prev) => {
        if (start < 0 || end < 0 || start > end) return

        if (start === 0 && end === 0) {
          results.push(prev)
          return
        }

        recursion(start - 1, end, prev + '(')
        recursion(start, end - 1, prev + ')')
      }

      recursion(n, n, '')
      return results
    }

    // 64. 最小路径和

    /**
   * @param {number[][]} grid
   * @return {number}
   */

    // dp[1][1]=1
    // dp[2][1] = 1+1
    // dp[1][2] = 1+3
    // dp[2][2] = 1+1+5
    // dp[i][j] = Math.min(dp[i][j-1]+grid[i][j], dp[i-1][j]+grid[i][j])

    // 边界时：dp[1][j]=dp[1][j-1]+grid[i][j]
    // 边界时：dp[i][1]=dp[i-1][1]+grid[i][j]

    // grid[i - 1][j - 1] 配合 m+1和n+1  注意m n 谁是谁!!!

    var minPathSum = function (grid) {
      const m = grid.length
      const n = grid[0].length
      let dp = new Array(m + 1).fill(0).map(v => new Array(n + 1).fill(0))

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (i === 1) dp[1][j] = dp[1][j - 1] + grid[i - 1][j - 1]
          else if (j === 1) dp[i][1] = dp[i - 1][j] + grid[i - 1][j - 1]
          else dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i - 1][j - 1]
        }
      }

      return dp[m][n]
    }


    // 146. LRU 缓存机制

    /**
   * @param {number} capacity
   */

    //  这题彻底把我搞服，终于知道什么场景下必须用链表了，要达到O(1)数组直接没考虑！！！
    //时间戳没法判断 前后，因为程序太快了，都毫秒都是一样
    // var LRUCache = function (capacity) {
    //   this.nowlength= 0
    //   this.totleLength = capacity
    // }

    // /** 
    //  * @param {number} key
    //  * @return {number}
    //  */
    // LRUCache.prototype.get = function (key) {
    //   if(this[key]){
    //     const nowTime = new Date()
    //     this[key].usageTimes= nowTime.valueOf()
    //     return this[key].val
    //   }else{
    //     return -1
    //   }
    // }

    // /** 
    //  * @param {number} key 
    //  * @param {number} value
    //  * @return {void}
    //  */
    // LRUCache.prototype.put = function (key, value) {
    //   if (this.nowlength >= this.totleLength) {
    //     let deleteKey = {
    //       usageTimes: Infinity
    //     }
    //     let indexKey= Infinity

    //     for (let i in this) {
    //       if (typeof this[i] === 'object' && deleteKey.usageTimes > this[i].usageTimes) {
    //         deleteKey = this[i]
    //         indexKey = i
    //       }
    //     }
    //     delete this[indexKey]
    //   }else if(this.nowlength < this.totleLength){
    //     this.nowlength+=1
    //   }

    //   const nowTime = new Date()
    //   this[key]={
    //     val: value,
    //     usageTimes: nowTime.valueOf()
    //   }
    // }

    class DoubleNode {
      constructor(key, val) {
        this.key = key
        this.val = val

        this.prev = null
        this.next = null
      }
    }

    class LRUCache {
      constructor(max) {
        this.max = max
        this.map = new Map()

        this.head = null
        this.tail = null
      }

      get(key) {
        const node = this.map.get(key)
        if (!node) {
          return -1
        } else {
          const res = node.val
          this.remove(node)
          this.appendHead(node)
          return res
        }
      }

      put(key, value) {
        let node = this.map.get(key)
        if (node) {
          node.val = value
          this.remove(node)
          this.appendHead(node)
        } else {
          node = new DoubleNode(key, value)
          if (this.map.size >= this.max) {
            this.map.delete(this.tail.key)
            this.remove(this.tail)
            this.appendHead(node)
            this.map.set(key, node)
          } else {
            this.appendHead(node)
            this.map.set(key, node)
          }
        }
      }

      /**
       * 把头部指针的改变成新的node
       * @param {DoubleNode} node
       */
      appendHead(node) {
        if (this.head === null) {
          this.head = this.tail = node
        } else {
          node.next = this.head
          this.head.prev = node
          this.head = node
        }
      }

      /**
       * 删除某个节点
       * @param {DoubleNode} node
       */
      remove(node) {
        if (this.head === this.tail) {
          this.head = this.tail = null
        } else {
          if (this.head === node) {
            this.head = this.head.next
            node.next = null
          } else if (this.tail === node) {
            this.tail = this.tail.prev
            this.tail.next = null
            node.prev = null
          } else {
            node.prev.next = node.next
            node.next.prev = node.prev
            node.prev = node.next = null
          }
        }
      }
    }


    // 209. 长度最小的子数组

    /**
   * @param {number} target
   * @param {number[]} nums
   * @return {number}
   */
    var minSubArrayLen = function (target, nums) {
      let result = Infinity

      for (let i = 0; i < nums.length; i++) {
        let totleNum = nums[i]
        let index = 1
        if (totleNum >= target) {
          result = Math.min(result, index)
          break;
        }
        for (let j = i + 1; j < nums.length; j++) {
          totleNum += nums[j]
          index += 1
          if (totleNum >= target) {
            result = Math.min(result, index)
            break;
          }
        }
      }

      return result === Infinity ? 0 : result
    }

    //滑动窗口方式

    var minSubArrayLen = function (target, nums) {
      let left = 0
      let right = - 1
      let sum = 0
      let result = Infinity

      while (left < nums.length) {
        if (sum < target) {
          sum += nums[++right]
        } else {
          sum -= nums[left]
          left++
        }
        if (sum >= target) {
          result = Math.min(result, right - left + 1)
        }
      }
      return result === Infinity ? 0 : result
    }

    // 416. 分割等和子集(01背包变种)

    /**  动规
   * @param {number[]} nums
   * @return {boolean}
   */
    var canPartition = function (nums) {
      const total = nums.reduce((t, v) => t + v)
      const isGetBoo = total % 2 === 0
      if (!isGetBoo) return false

      let sum = total / 2 //背包重量
      let n = nums.length

      // 初始化二维数组 (n + 1)行，(sum/2 + 1)列
      let dp = []
      for (let i = 0; i < n + 1; i++) {
        dp[i] = []
        for (let j = 0; j < sum + 1; j++) {
          // base case，dp[..][0] = true 和 dp[0][..] = false，其余为false
          dp[i][j] = j === 0 ? true : false
        }
      }

      for (let i = 1; i < n + 1; i++) {
        for (let j = 1; j < sum + 1; j++) {
          // 当前背包容量j不够装下第i个物品的重量nums[i-1]时，只有选择不装
          if (j - nums[i - 1] < 0) {
            dp[i][j] = dp[i - 1][j]
          } else {
            // 有两种选择 不装 或 装，用 或 表示选哪种能装满
            dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]
          }
        }
      }

      return dp[n][sum]
    }

    // 更易理解的01背包
    // 重量和物品价值相等
    // dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
    var canPartition = function (nums) {
      const total = (nums.reduce((p, v) => p + v));
      const isGetBoo = total % 2 === 0
      if (!isGetBoo) return false //有余数代表不能均分为二
      let sum = total / 2 //背包重量

      const dp = Array(sum + 1).fill(0);
      for (let i = 0; i < nums.length; i++) {
        for (let j = sum; j >= nums[i]; j--) { //j >= nums[i] 背包必须比物品大
          dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
          if (dp[j] === sum) {
            return true;
          }
        }
      }
      return dp[sum] === sum; // 当背包装满dp[sum] 的价值 等于 数组一半的重量，代表ok
    };

    // 92. 反转链表 II

    /**
   * @param {ListNode} head
   * @param {number} left
   * @param {number} right
   * @return {ListNode}
   */

    //注意引用类型特点，变量赋值另一个变量，变量改变不影响变量，但是变量的引用改变，另一个变量会改变。链表玩的就是引用，搞清楚这个，下面19就很简单了
    var reverseBetween = function (head, left, right) {
      let i = 1
      let current = head
      let curHead = null
      let curHeadPre = null
      let curEnd = null

      const getRecursionImSaveEnd = (current) => {
        if (i === left - 1) {
          curHeadPre = current
        }

        if (i === left) {
          curHead = current
        }

        if (i === right) {
          curEnd = current
        }

        i++

        if (current.next) {
          getRecursionImSaveEnd(current.next)
        }
      }
      getRecursionImSaveEnd(current)

      let saveEnd = curEnd.next
      curEnd.next = null

      const { reverMiddle, endNode } = reverse(curHead)
      if (curHeadPre) {
        curHeadPre.next = reverMiddle
      } else {
        head = reverMiddle
      }
      endNode.next = saveEnd


      function reverse(head) {
        let prev = null
        let cur = head
        while (cur) {
          let next = cur.next
          cur.next = prev

          prev = cur
          cur = next
        }
        return { reverMiddle: prev, endNode: head }
      }

      return head
    }

    // const obj = {
    //   val: 1,
    //   next: {
    //     val: 2,
    //     next: {
    //       val: 3,
    //       next: {
    //         val: 4,
    //         next: {
    //           val: 5
    //         }
    //       }
    //     }
    //   }
    // }

    // 19. 删除链表的倒数第 N 个结点

    /**
   * @param {ListNode} head
   * @param {number} n
   * @return {ListNode}
   */
    //链表太恶心了，还是转数组吧
    //可以用快慢指针，2慢=快，快index-慢index-Nindex=慢头正数位置来处理
    var removeNthFromEnd = function (head, n) {
      let i = 1
      let current = head
      let arr = []
      const getArr = (current) => {
        arr.unshift(current.val)
        if (current.next) {
          getArr(current.next)
        }
      }
      getArr(current)
      arr.splice(n - 1, 1)

      let _cur = null
      for (let i = 0; i < arr.length; i++) {
        _cur = {
          val: arr[i],
          next: _cur
        }
      }
      return _cur
    }

    // 438. 找到字符串中所有字母异位词

    /** 滑动窗口 
   * @param {string} s
   * @param {string} p
   * @return {number[]}
   */

    //  p排序后对比和获取p所有排列均超时
    var findAnagrams = function (s, p) {
      const _p = p.split('').sort().join('')
      const res = []
      let left = 0, right = p.length - 1, sl = s.length

      while (right < sl) {
        const str = s.substring(left, right + 1).split('').sort().join('')
        console.log(str)
        if (str === _p) {
          res.push(left)
        }
        left++
        right++
      }

      return res
    }

    //map比较好想,只有str和p中相同字母数量一样是异位词
    var findAnagrams = function (s, p) {
      function addCountToMap(map, str) {
        if (!map[str]) {
          map[str] = 1
        } else {
          map[str]++
        }
      }

      function makeCountMap(strs) {
        let map = {}
        for (let i = 0; i < strs.length; i++) {
          let letter = strs[i]
          addCountToMap(map, letter)
        }
        return map
      }

      const sl = s.length
      const pl = p.length
      //异位特点窗口长度不变
      let left = 0
      let right = pl - 1
      let result = []
      let targetMap = makeCountMap(p)
      let windowMap = makeCountMap(s.substring(left, right + 1))

      const getIfMetCondition = windowMap => {
        for (key in targetMap) {
          let targetCount = targetMap[key]
          let count = windowMap[key]
          if (!count || count < targetCount) {
            return false
          }
        }
        return true
      }

      while (left <= sl - pl && right < sl) {
        if (getIfMetCondition(windowMap)) {
          result.push(left)
        }
        //左右一起滑
        windowMap[s[left]]--
        left++
        right++
        addCountToMap(windowMap, s[right])
      }

      return result
    }

    //技巧：由小写字母组成，两字母则unicode之差不会大于26
    //时间比map更优秀，遍历更少。但是charCodeAt内存开销会更大
    var findAnagrams = function (s, p) {
      const sLen = s.length, pLen = p.length;

      if (sLen < pLen) {
        return [];
      }

      const ans = [];
      const sCount = new Array(26).fill(0);
      const pCount = new Array(26).fill(0);
      for (let i = 0; i < pLen; ++i) {
        ++sCount[s[i].charCodeAt() - 'a'.charCodeAt()];
        ++pCount[p[i].charCodeAt() - 'a'.charCodeAt()];
      }
      const _pCountStr = pCount.toString()

      if (sCount.toString() === _pCountStr) {
        ans.push(0);
      }

      for (let i = 0; i < sLen - pLen; ++i) {
        --sCount[s[i].charCodeAt() - 'a'.charCodeAt()]; //滑动窗口还原left位置
        ++sCount[s[i + pLen].charCodeAt() - 'a'.charCodeAt()];

        if (sCount.toString() === _pCountStr) {
          ans.push(i + 1); //i(left)位置还原,所以是i+1开始
        }
      }

      return ans;
    }

    // 150. 逆波兰表达式求值

    /** 栈和队列
   * @param {string[]} tokens
   * @return {number}
   */
    var evalRPN = function (tokens) {
      let stack = []
      const opMap = {
        '+': (a, b) => a + b,
        '-': (a, b) => a - b,
        '*': (a, b) => a * b,
        '/': (a, b) => a / b,
      }

      for (token of tokens) {
        const op = opMap[token]
        if (op) {
          const a = parseInt(stack.pop())
          const b = parseInt(stack.pop())
          const res = parseInt(op(b, a))
          stack.push(res)
        } else {
          stack.push(token)
        }
      }
      return stack[0]
    }

    // 71. 简化路径

    /**  栈和队列
   * @param {string} path
   * @return {string}
   */
    var simplifyPath = function (path) {
      const arr = path.split('/')
      let stack = []

      for (let i = 0; i < arr.length; i++) {
        const item = arr[i]
        if (item === '..') {
          stack?.length && stack.pop()
        } else if (!(item === '.' || item === '')) {
          stack.push(item)
        }
      }

      return '/' + stack.join('/')
    }

    // 199.二叉树的右视图

    /** bfs
   * @param {TreeNode} root
   * @return {number[]}
   */

    //旧思维：这题有点扯，跟着示例只取右边不对（没考虑每层只存在子左叶子结点）
    //新理解：取每层最右边即可
    var rightSideView = function (root) {
      if (!root) return []
      let queue = [root]
      let result = []

      while (queue.length) {
        let len = queue.length

        for (let i = 0; i < len; i++) {
          const node = queue.shift()
          i === len - 1 && result.push(node.val)
          node.left && queue.push(node.left)
          node.right && queue.push(node.right)
        }
      }
      return result
    }

    //[1,2]的时候2在左，但是看得到
    var rightSideView = function (root) {
      if (!root) return []
      let queue = [root]
      let result = []

      while (queue.length) {
        let len = queue.length
        let lastRight //取每行的最后一个

        for (let i = 0; i < len; i++) {
          const node = queue.shift()
          node.left && queue.push(node.left)
          node.right && queue.push(node.right)
          if (node.val !== null) lastRight = node.val
        }
        result.push(lastRight)
      }
      return result
    }

    // 24. 两两交换链表中的节点

    /** 
   * @param {ListNode} head
   * @return {ListNode}
   */
    var swapPairs = function (head) {
      if (!head) return null
      let arr = []
      const recursion = node => {
        arr.unshift(node.val)
        node.next && recursion(node.next)
      }
      recursion(head)

      let last
      const isEvenNumbers = arr.length % 2 === 0
      let _arr = isEvenNumbers ? arr : (last = arr.shift(), arr)

      for (let i = 0; i < _arr.length; i++) {
        if (i % 2 === 0) {
          [_arr[i], _arr[i + 1]] = [_arr[i + 1], _arr[i]]
        }
      }

      !isEvenNumbers && (_arr.unshift(last))

      let _cur = null
      for (let i = 0; i < _arr.length; i++) {
        _cur = {
          val: arr[i],
          next: _cur
        }
      }
      return _cur
    }

    //上一个算法真挺牛逼，硬写还能通过提测，这次虽然时间更少，但是内存消耗更高了
    //链表重点还是引用
    var swapPairs = function (head) {
      if (head === null || head.next === null) {
        return head;
      }
      const newHead = head.next;
      head.next = swapPairs(newHead.next);
      newHead.next = head;
      return newHead;
    };

    // 129. 求根节点到叶节点数字之和

    /**
   * @param {TreeNode} root
   * @return {number}
   */
    var sumNumbers = function (root) {
      if (!root) return 0
      let results = []

      const recursion = (node, totalSum) => {
        totalSum = totalSum + '' + node.val
        if (!node.left && !node.right) {
          results.push(totalSum)
        }
        node.left && recursion(node.left, totalSum)
        node.right && recursion(node.right, totalSum)
      }

      recursion(root, 0)
      return results.reduce((total, v) => total + Number(v), 0)
    }

    // 437. 路径总和 III
    /**
   * @param {TreeNode} root
   * @param {number} targetSum
   * @return {number}
   */

    // 把所有路径拿到,再依次对比二维数组 思路可行，但增加时间空间复杂度
    // 暴力递归
    // 以根,左,右分别为顶点开始计数（开始计数位置不会重复）, 向下递归
    var pathSum = function (root, targetSum) {
      if (!root) return 0

      const countSum = (node) => {
        let count = 0
        let dfs = (node, sum) => {
          if (!node) return

          sum += node.val
          if (sum === targetSum) {
            count += 1
          }
          node.left && dfs(node.left, sum)
          node.right && dfs(node.right, sum)
        }

        dfs(node, 0)
        return count
      }

      return countSum(root) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum)
    }

    // 450. 删除二叉搜索树中的节点
    /**
   * @param {TreeNode} root
   * @param {number} key
   * @return {TreeNode}
   */


    // 遍历，
    // 如果val等于key
    // 没有左右子树直接删除
    // 只有左子树，替换成左子树
    // 只有右子树，替换成右子树
    // 有左子树，有右子树，则替换成右子树，左子树暂存
    // 如有暂存的数据，赋值到没有左子树的子树上

    // 二叉搜索树：左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值=》得到以上结论

    var deleteNode = function (root, key) {
      let saveNode

      const dfs = (node) => {
        if (!node) return null

        if (node.val === key) {
          if (!node.left && !node.right) node = null
          else if (node.left && !node.right) node = node.left
          else if (!node.left && node.right) node = node.right
          else if (node.left && node.right) {
            saveNode = node.left
            node = node.right
          }
        }

        if (saveNode && !node.left) (node.left = saveNode, saveNode = null)
        if (node && node.left) node.left = dfs(node.left)
        if (node && node.right) node.right = dfs(node.right)

        return node
      }
      return dfs(root)
    }


    // 236. 二叉树的最近公共祖先

    /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   *     this.val = val;
   *     this.left = this.right = null;
   * }
   */

    /**
   * @param {TreeNode} root
   * @param {TreeNode} p
   * @param {TreeNode} q
   * @return {TreeNode}
   */

    //1.p,q包含
    //2.左右子树只有1个会包含p,q
    // 我的答案跑起来对的，leetcode报错
    var lowestCommonAncestor = function (root, p, q) {
      let queue = [root]
      let result

      const getIsHas = (node) => {
        if (!node) return
        let _pBoo = false, _qBoo = false
        const dfs = (node) => {
          if (node.val === p) _pBoo = true
          if (node.val === q) _qBoo = true
          if (_pBoo && _qBoo) return true

          node.left && dfs(node.left, _pBoo, _qBoo)
          node.right && dfs(node.right, _pBoo, _qBoo)

        }
        dfs(node)
        return _pBoo && _qBoo
      }

      while (queue.length) {
        let len = queue.length

        for (let i = 0; i < len; i++) {
          const node = queue.shift()

          if (getIsHas(node)) result = node

          node.left && queue.push(node.left)
          node.right && queue.push(node.right)
        }
      }

      return result
    }

    // 题解leetcode对的，跑起来错的
    //  var lowestCommonAncestor = function (root, p, q) {
    //     if (root == null || root == p || root == q) return root
    //     const left = lowestCommonAncestor(root.left, p, q)
    //     const right = lowestCommonAncestor(root.right, p, q)
    //     if (left === null) return right
    //     if (right === null) return left
    //     return root
    //   }

    // const obj = {
    //   val: 3,
    //   left: {
    //     val: 5,
    //     left: {
    //       val: 6
    //     },
    //     right: {
    //       val: 2,
    //       left: {
    //         val: 7
    //       },
    //       right: {
    //         val: 4
    //       }
    //     }
    //   },
    //   right: {
    //     val: 1,
    //     left: {
    //       val: 0
    //     },
    //     right: {
    //       val: 8
    //     }
    //   }
    // }

    // console.log(lowestCommonAncestor(obj, 0, 8))


    //46. 全排列

    /**  回溯与递归
   * @param {number[]} nums
   * @return {number[][]}
   */

    //思路解析：
    //1. [1, 2, 3] 可以分割为 3 和 permute([1, 2]) 的所有组合
    //2. 递归1
    //3. 结束条件：当nums为1, 只有1种组合
    //4. 见下面
    var permute = function (nums) {
      let results = []

      const recursion = (nums, res) => {
        if (nums.length === 1) {
          results.push([...res, ...nums])
        }

        for (let i = 0; i < nums.length; i++) {
          const _num = nums[i]
          const _nums = nums.slice(0, i).concat(nums.slice(i + 1))
          //每次遍历, 保证剩下的数组是一样, 并且每个位置都要开头一次
          res.push(_num)
          recursion(_nums, res)
          //开过头就删除, 避免同一个数组所加的res除开nums[i]前面的数与_nums有重复
          res.pop()
          // recursion(_nums,[...res, nums[i]]) //或者直接解构，运行时间更短
        }
      }

      recursion([...nums], [])

      return results
    }

    // 47. 全排列 II

    /** 回溯与递归 + 剪枝
   * @param {number[]} nums
   * @return {number[][]}
   */

    //简单去重
    var permuteUnique = function (nums) {
      let results = new Set()

      const recursion = (nums, res) => {
        if (nums.length === 1) {
          const _res = [...res, ...nums].join()
          results.add(_res)
        }

        for (let i = 0; i < nums.length; i++) {
          const _num = nums[i]
          const _nums = nums.slice(0, i).concat(nums.slice(i + 1))
          res.push(_num)
          recursion(_nums, res)
          res.pop()
        }
      }

      recursion([...nums], [])

      return [...results].map(v => v.split(',').map(Number))
    }

    // 每层同样的number为首尾的continue本层  剪枝
    var permuteUnique = function (nums) {
      let results = []

      const recursion = (nums, res) => {
        let dup = []
        if (nums.length === 1) {
          results.push([...res, ...nums])
        }

        for (let i = 0; i < nums.length; i++) {
          const _num = nums[i]
          if (dup.includes(_num)) continue
          else dup.push(_num)
          const _nums = nums.slice(0, i).concat(nums.slice(i + 1))
          res.push(_num)
          recursion(_nums, res)
          res.pop()
        }
      }

      recursion([...nums], [])

      return results
    }

    // 77. 组合

    /** 回溯与递归 + 变形回溯
   * @param {number} n
   * @param {number} k
   * @return {number[][]}
   */

    //  输入: n = 4, k = 2
    //
    //   输出:
    //   [
    //     [2, 4],
    //     [3, 4],
    //     [2, 3],
    //     [1, 2],
    //     [1, 3],
    //     [1, 4],
    //   ]

    // 1.第一层数组减少1个
    // 2.第二层数组每个节点减少1个
    // 3.总结规律：每次取值，数组都要减少一个
    // 这里基本是这类题，我的万能模板 + 剪枝的更胜
    var combine = function (n, k) {
      let results = []
      let arr = new Array(n).fill(0).map((v, i) => i + 1)
      const recursion = (k, arr, res) => {
        if (k === 0) return results.push(res)
        k--

        while (arr.length) {
          const num = arr.shift()
          // res.push(num)
          recursion(k, [...arr], [...res, num])
          // res.pop()
        }
      }

      recursion(k, arr, [])

      return results
    }

    var combine = function (n, k) {
      const results = []
      let arr = new Array(n).fill(0).map((v, i) => i + 1)

      const helper = (arr, res) => {
        if (res.length === k) {
          results.push(res)
        }

        while (arr.length) {
          const num = arr.shift()
          helper([...arr], [...res, num])
        }
      }
      helper(arr, [])
      return results
    }

    var combine = function (n, k) {
      const results = []

      const helper = (_n, res) => {
        if (res.length === k) {
          results.push(res)
        }

        for (let i = _n; i > 0; i--) {
          res.push(i)
          helper(i - 1, [...res])
          res.pop()
        }
      }
      helper(n, [])
      return results
    }

    // 78. 子集

    /** 回溯与递归 + 变形回溯
   * @param {number[]} nums
   * @return {number[][]}
   */

    //优化
    var subsets = function (nums) {
      let results = []
      let len = nums.length

      const recursion = (k, arr, res) => {
        if (k === 0) return results.push(res)
        k--

        while (arr.length) {
          const num = arr.shift()
          recursion(k, arr.slice(), res.concat(num))
        }
      }

      for (let i = 0; i <= len; i++) {
        recursion(i, nums.slice(), [])
      }

      return results
    }

    //时间复杂度优，合并两次循环
    var subsets = function (nums) {
      const res = []

      const recursion = (arr, start) => {
        res.push([...arr])
        for (let i = start; i < nums.length; i++) {
          recursion([...arr, nums[i]], i + 1)
        }
      }
      recursion([], 0)
      return res
    };

    // 90. 子集 II

    /**  回溯与递归 + 变形回溯 + 剪枝
   * @param {number[]} nums
   * @return {number[][]}
   */

    // 88ms,超85%
    var subsetsWithDup = function (nums) {
      let results = []

      //debugger才得知4,1,4 不排序,会导致第二层开始，导致某些项不该继续递归但漏掉=>k为0添加到results
      // 414组合,第一层4和第一层4的第二层1，组合成4,1。第一层4和第二层的4也会组成4,4。第一层的1和第一层1和第二层4，组合成1,4。
      // 排序后144, 第一层1和第二层的4，组合成1,4。第一层的1和第二层的第二个4组合之前，会被dup里面的第二层第一个4 continue出去。同理，第一层的4和第二层的4，组合成4，4.
      // 排序后相同的相连，不会出现414情况，因为第一层到第二层的dup不会累计，而第一层的res和第二层除开第一个数之后的数会组合。
      nums.sort((a, b) => a - b)
      const recursion = (k, arr, res) => {
        if (k === 0) return results.push(res)
        let dup = new Set()
        k--

        while (arr.length) {
          const num = arr.shift()
          if (dup.has(num)) continue
          else dup.add(num)
          // res.push(num)
          recursion(k, [...arr], [...res, num])
          // res.pop()
        }
      }

      for (let i = 0; i <= nums.length; i++) {
        recursion(i, [...nums], [])
      }

      return results
    }


    //另一种方式也要排序才行，但是效率差了很多 112ms，超12%
    // var subsetsWithDup = function (nums) {
    //   let results = []

    //   nums.sort((a, b) => a - b)
    //   const recursion = (k, arr, res) => {
    //     if (k === 0) return results.push(res)
    //     let dup = new Set()
    //     k--

    //     for (let i = 0; i < arr.length; i++) {
    //       const num = arr[i]
    //       if (dup.has(num)) continue
    //       else dup.add(num)
    //       const _arr = arr.slice(i+1)
    //       res.push(num)
    //       recursion(k, [..._arr], [...res])
    //       res.pop()
    //     }
    //   }

    //   for (let i = 0; i <= nums.length; i++) {
    //     recursion(i, [...nums], [])
    //   }

    //   return results
    // }

    var subsetsWithDup = function (nums) {
      const res = []
      nums.sort((a, b) => a - b)
      const recursion = (arr, start) => {
        let dp = {}
        res.push([...arr])
        for (let i = start; i < nums.length; i++) {
          if (!dp[nums[i]]) {
            dp[nums[i]] = 1
            recursion([...arr, nums[i]], i + 1, dp)
          }
        }
      }
      recursion([], 0)
      return res
    };


    // 39. 组合总和

    /**  回溯与递归
   * @param {number[]} candidates
   * @param {number} target
   * @return {number[][]}
   */

    // 这题引入的新概念，之前的回溯模板不能解决, 找最小遍历例子，找到关键点
    // 本层剪枝, 但是下一层的是上一层同样剪枝结果后的数组  关键点 垂直数组相等!!!
    // 新理解i为0 和i+1 同步向下走，关键是剪枝
    var combinationSum = function (candidates, target) {
      let results = []

      const recursion = (sum, curRes, index) => {
        if (sum === target) return results.push(curRes)

        for (let i = index; i < candidates.length; i++) {
          if (sum + candidates[i] <= target) {
            recursion(sum + candidates[i], [...curRes, candidates[i]], i)  // 这里是关键，每次从 i 开始，既不能shift数组，也不能传完整数组
          } else continue
        }
      }

      recursion(0, [], 0)
      return results
    }

    // 40. 组合总和 II

    /**  回溯与递归
   * @param {number[]} candidates
   * @param {number} target
   * @return {number[][]}
   */

    var combinationSum2 = function (candidates, target) {
      let results = []

      candidates.sort()
      const recursion = (arr, sum, curRes) => {
        if (sum > target) return
        if (sum === target) return results.push(curRes)
        let dup = new Set()

        while (arr.length) {
          const num = arr.shift()
          if (dup.has(num)) continue  //排除横向的相同，但是向下的arr中没有排除同一个数，所以向下的arr第二个答案依然可以用重复的数
          else dup.add(num)
          recursion([...arr], sum + num, [...curRes, num])
        }
      }

      recursion(candidates, 0, [])

      return results
    }

    var combinationSum2 = function (candidates, target) {
      let results = []

      candidates.sort()
      const recursion = (sum, curRes, index) => {
        if (sum > target) return
        if (sum === target) return results.push(curRes)
        let sameArr = []

        for (let i = index; i < candidates.length; i++) {
          if (sameArr.includes(candidates[i])) continue
          else {
            sameArr.push(candidates[i])
            recursion(sum + candidates[i], [...curRes, candidates[i]], i + 1)
          }
        }
      }

      recursion(0, [], 0)
      return results
    };

    // 216. 组合总和 III
    /**  回溯与递归
   * @param {number} k
   * @param {number} n
   * @return {number[][]}
   */

    //这种模版相对于arr.shift()更加灵活，多多体会并使用
    var combinationSum3 = function (k, n) {
      let results = []

      const recursion = (index, sum, res) => {
        if (sum > n || res.length > k) return void (0)
        if (sum === n && res.length === k) return results.push(res)

        for (let i = index; i <= 9; i++) {
          recursion(i + 1, sum + i, [...res, i])
        }
      }

      recursion(1, 0, [])
      return results
    }

    // 79. 单词搜索

    /**  回溯与递归
   * @param {character[][]} board
   * @param {string} word
   * @return {boolean}
   */

    // 卧槽, 思维转化代码难
    var exist = function (board, word) {
      let boo = false
      let row, col
      const m = board.length
      const n = board[0].length

      const dfsCoordinate = (row, col, k) => {
        if (row < 0 || col < 0 || row >= board.length || col >= board[0].length || board[row][col] !== word[k]) return false
        if (k === word.length - 1) return boo = true
        board[row][col] = '' // 标记下已经查找过的q
        let res = dfsCoordinate(row - 1, col, k + 1) || dfsCoordinate(row + 1, col, k + 1) || dfsCoordinate(row, col - 1, k + 1) || dfsCoordinate(row, col + 1, k + 1)
        board[row][col] = word[k]
        return res
      }


      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (board[i][j] === word[0]) {
            dfsCoordinate(i, j, 0)
            if (boo) return boo
          }
        }
      }
      return boo
    }


    // 207. 课程表

    /** 拓扑排序(了解)
     * @param {number} numCourses
     * @param {number[][]} prerequisites
     * @return {boolean}
     */

    //构建有向无环图
    class Graph {
      constructor(noOfVertices) {
        this.noOfVertices = noOfVertices; // 顶点数量
        this.adjList = new Map(); // 邻接表
      }

      // 增加顶点
      addVertex(v) {
        this.adjList.set(v, []);
      }

      // 增加单向边
      addEdge(v, w) {
        this.adjList.get(v).push(w);
      }

      dfs() {
        const visited = Array(this.noOfVertices).fill(false);
        const vertices = this.adjList.keys();
        console.log(vertices)
        for (let v of vertices) {
          if (!this.dfsUntil(v, visited)) return false;
        }
        return true;
      }
      dfsUntil(v, visited) {
        if (visited[v]) return false
        visited[v] = true

        const neighs = this.adjList.get(v);
        for (let neigh of neighs) {
          if (!this.dfsUntil(neigh, visited)) return false;
        }
        visited[v] = false;
        return true;
      }
    }

    var canFinish = function (numCourses, prerequisites) {
      var g = new Graph(numCourses)
      for (var i = 0; i < numCourses; i++) {
        g.addVertex(i)
      }
      prerequisites.forEach(([i, j]) => g.addEdge(i, j))
      return g.dfs()
    }


  </script>
</body>

</html>