<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 09. 用两个栈实现队列
    var CQueue = function () {
      this.stackA = []
      this.stackB = []
    }

    /** 
     * @param {number} value
     * @return {void}
     */
    CQueue.prototype.appendTail = function (value) {
      this.stackA.push(value)
    }

    /**
     * @return {number}
     */
    CQueue.prototype.deleteHead = function () {
      // 两个栈都没有元素
      if (!this.stackA.length && !this.stackB.length) return -1;
      // 删除栈没元素，从插入栈拿
      if (!this.stackB.length) {
        while (this.stackA.length) {
          this.stackB.push(this.stackA.pop())
        }
      }
      // 删除栈有元素，直接删
      return this.stackB.pop()
    }

    // 30. 包含min函数的栈

    /**
   * initialize your data structure here.
   */
    var MinStack = function () {
      this.stack = []
      this.minStack = []
    }

    /** 
     * @param {number} x
     * @return {void}
     */
    MinStack.prototype.push = function (x) {
      this.stack.push(x)
      if (!this.minStack.length || this.minStack[this.minStack.length - 1] >= x) {
        this.minStack.push(x)
      }
    }

    /**
     * @return {void}
     */
    MinStack.prototype.pop = function () {
      if (this.minStack[this.minStack.length - 1] === this.stack.pop()) {
        this.minStack.pop()
      }
    }

    /**
     * @return {number}
     */
    MinStack.prototype.top = function () {
      return this.stack[this.stack.length - 1]
    }

    /**
     * @return {number}
     */
    MinStack.prototype.min = function () {
      if (this.minStack.length == 0) {
        return 1
      }
      return this.minStack[this.minStack.length - 1]
    }

    // 06. 从尾到头打印链表
    /**
   * @param {ListNode} head
   * @return {number[]}
   */
    var reversePrint = function (head) {
      let cur = head

      while (cur) {
        result.unshift(cur.val)
        cur = cur.next
      }

      return result
    }

    // 53 - II. 0～n - 1中缺失的数字

    /**
   * @param {number[]} nums
   * @return {number}
   */
    var missingNumber = function (nums) {
      nums.push('x')
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== i)
          return i
      }
    }

    //04. 二维数组中的查找
    /**
     * @param {number[][]} matrix
     * @param {number} target
     * @return {boolean}
     */
    var findNumberIn2DArray = function (matrix, target) {
      if (!matrix.length) return false;
      const colLen = matrix.length
      const rowLen = matrix[0].length
      let end = colLen - 1

      for (let i = 0; i < colLen; i++) {
        if (target < matrix[i][0]) {
          end = i - 1
          break
        }
        if (target === matrix[i][0]) {
          return true
        }
      }

      for (let i = 0; i <= end; i++) {
        if (target <= matrix[i][rowLen - 1]) {
          if (matrix[i].indexOf(target) !== -1) {
            return true
          }
        }
      }

      return false
    }

    //从左下角开始找
    var findNumberIn2DArray = function (matrix, target) {
      if (!matrix.length) return false;
      let l = matrix.length - 1
      const rMax = matrix[0].length - 1
      let r = 0

      while (l >= 0 && r <= rMax) {
        if (matrix[l][r] > target) {
          l--
        } else if (matrix[l][r] < target) {
          r++
        } else {
          return true
        }
      }

      return false
    }

    // 11. 旋转数组的最小数字

    /**
   * @param {number[]} numbers
   * @return {number}
   */
    //二分
    var minArray = function (numbers) {
      let l = 0, r = numbers.length - 1

      while (l < r) {
        const mid = Math.floor((l + r) / 2)
        if (numbers[mid] > numbers[r]) {
          l = mid + 1
        } else if (numbers[mid] < numbers[r]) {
          r = mid
        } else {
          r--
        }
      }
      return numbers[l]
    }


    // 32 - I.从上到下打印二叉树
    /**
     * @param {TreeNode} root
     * @return {number[]}
     */
    var levelOrder = function (root) {
      if (!root) return []
      let queue = [root]
      let results = []

      while (queue.length) {
        let len = queue.length
        for (let i = 0; i < len; i++) {
          const node = queue.shift()
          results.push(node.val)
          node.left && queue.push(node.left)
          node.right && queue.push(node.right)
        }
      }
      return results
    }

    // 32 - II. 从上到下打印二叉树 II

    /**
   * @param {TreeNode} root
   * @return {number[][]}
   */
    var levelOrder = function (root) {
      if (!root) return []
      let queue = [root]
      let results = []

      while (queue.length) {
        let len = queue.length
        let result = []
        for (let i = 0; i < len; i++) {
          const node = queue.shift()
          result.push(node.val)
          node.left && queue.push(node.left)
          node.right && queue.push(node.right)
        }
        results.push(result)
      }
      return results
    }

    // 32 - III.从上到下打印二叉树 III
    /**
     * @param {TreeNode} root
     * @return {number[][]}
     */
    var levelOrder = function (root) {
      if (!root) return []
      let queue = [root]
      let results = []
      let dir = true

      while (queue.length) {
        let len = queue.length
        let result = []
        for (let i = 0; i < len; i++) {
          const node = queue.shift()
          dir ? result.push(node.val) : result.unshift(node.val)
          node.left && queue.push(node.left)
          node.right && queue.push(node.right)

        }
        dir = !dir
        results.push(result)
      }
      return results
    }

    //  27. 二叉树的镜像

    /**
   * @param {TreeNode} root
   * @return {TreeNode}
   */
    var mirrorTree = function (root) {
      if (!root) return null

      const left = mirrorTree(root.left)
      const right = mirrorTree(root.right)
      root.left = right
      root.right = left
      return root
    }
    var mirrorTree = function (root) {
      const dfs = (node) => {
        if (node) {
          [node.left, node.right] = [node.right, node.left]
          node.left && dfs(node.left)
          node.right && dfs(node.right)
        }
      }
      dfs(root)
      return root
    }

    // 28. 对称的二叉树
    //参考leetcode

    // 26. 树的子结构
    /**
   * @param {TreeNode} A
   * @param {TreeNode} B
   * @return {boolean}
   */
    //考虑dfs会匹配多次的情况，如果用单独的变量，会以最后一次为准
    //所以只能动态helper的结果获得true,只要有一次，全局都是true
    //QAQ
    var isSubStructure = function (A, B) {
      if (!B) return false
      const valB = B.val

      function dfs(node) {
        if (!node) return false
        if (node.val === valB && helper(node, B)) return true
        return dfs(node.left) || dfs(node.right)
      }

      function helper(nodeA, nodeB) {
        if (nodeA && nodeB) {
          if (nodeA.val !== nodeB.val) return false
          return helper(nodeA.left, nodeB.left) && helper(nodeA.right, nodeB.right)
        }
        if (!nodeA && nodeB) return false //只有左树没有，右树有才是false

        return true
      }
      return dfs(A)
    }

    // 10 - II.青蛙跳台阶问题
    /** 动规
     * @param {number} n
     * @return {number}
     */
    var numWays = function (n) {
      let dp = [1, 1, 2]

      for (let i = 3; i <= n; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007
      }
      return dp[n]
    }

    //  63. 股票的最大利润
    /**
     * @param {number[]} prices
     * @return {number}
     */
    var maxProfit = function (prices) {
      let dp = [0], min = prices[0], len = prices.length
      if (len === 0) return 0
      for (let i = 1; i < len; i++) {
        min = Math.min(min, prices[i])
        dp[i] = Math.max(prices[i] - min, dp[i - 1])
      }
      return dp[len - 1]
    }

    //  42. 连续子数组的最大和
    /**
   * @param {number[]} nums
   * @return {number}
   */
    var maxSubArray = function (nums) {
      let dp = [], len = nums.length
      dp[0] = nums[0]
      for (let i = 1; i < len; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])
      }

      return Math.max(...dp)
    }


    // 47. 礼物的最大价值
    /**
   * @param {number[][]} grid
   * @return {number}
   */
    var maxValue = function (grid) {
      let rowLen = grid[0].length, colLen = grid.length
      let dp=new Array(colLen+1).fill(0).map(v=>new Array(rowLen+1).fill(0))

      for (let i = 1; i <= colLen; i++) {
        for (let j = 1; j <= rowLen; j++) {
          const curVal= grid[i - 1][j - 1]
          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])+ curVal
        }
      }

      return dp[colLen][rowLen]
    }



  </script>
</body>

</html>