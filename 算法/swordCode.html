<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 09. 用两个栈实现队列
    var CQueue = function () {
      this.stackA = []
      this.stackB = []
    }

    /** 
     * @param {number} value
     * @return {void}
     */
    CQueue.prototype.appendTail = function (value) {
      this.stackA.push(value)
    }

    /**
     * @return {number}
     */
    CQueue.prototype.deleteHead = function () {
      // 两个栈都没有元素
      if (!this.stackA.length && !this.stackB.length) return -1;
      // 删除栈没元素，从插入栈拿
      if (!this.stackB.length) {
        while (this.stackA.length) {
          this.stackB.push(this.stackA.pop())
        }
      }
      // 删除栈有元素，直接删
      return this.stackB.pop()
    }

    // 30. 包含min函数的栈

    /**
   * initialize your data structure here.
   */
    var MinStack = function () {
      this.stack = []
      this.minStack = []
    }

    /** 
     * @param {number} x
     * @return {void}
     */
    MinStack.prototype.push = function (x) {
      this.stack.push(x)
      if (!this.minStack.length || this.minStack[this.minStack.length - 1] >= x) {
        this.minStack.push(x)
      }
    }

    /**
     * @return {void}
     */
    MinStack.prototype.pop = function () {
      if (this.minStack[this.minStack.length - 1] === this.stack.pop()) {
        this.minStack.pop()
      }
    }

    /**
     * @return {number}
     */
    MinStack.prototype.top = function () {
      return this.stack[this.stack.length - 1]
    }

    /**
     * @return {number}
     */
    MinStack.prototype.min = function () {
      if (this.minStack.length == 0) {
        return 1
      }
      return this.minStack[this.minStack.length - 1]
    }

    // 06. 从尾到头打印链表
    /**
   * @param {ListNode} head
   * @return {number[]}
   */
    var reversePrint = function (head) {
      let cur = head

      while (cur) {
        result.unshift(cur.val)
        cur = cur.next
      }

      return result
    }

    // 53 - II. 0～n - 1中缺失的数字

    /**
   * @param {number[]} nums
   * @return {number}
   */
    var missingNumber = function (nums) {
      nums.push('x')
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== i)
          return i
      }
    }

    //04. 二维数组中的查找
    /**
     * @param {number[][]} matrix
     * @param {number} target
     * @return {boolean}
     */
    var findNumberIn2DArray = function (matrix, target) {
      if (!matrix.length) return false;
      const colLen = matrix.length
      const rowLen = matrix[0].length
      let end = colLen - 1

      for (let i = 0; i < colLen; i++) {
        if (target < matrix[i][0]) {
          end = i - 1
          break
        }
        if (target === matrix[i][0]) {
          return true
        }
      }

      for (let i = 0; i <= end; i++) {
        if (target <= matrix[i][rowLen - 1]) {
          if (matrix[i].indexOf(target) !== -1) {
            return true
          }
        }
      }

      return false
    }

    //从左下角开始找
    var findNumberIn2DArray = function (matrix, target) {
      if (!matrix.length) return false;
      let l = matrix.length - 1
      const rMax = matrix[0].length - 1
      let r = 0

      while (l >= 0 && r <= rMax) {
        if (matrix[l][r] > target) {
          l--
        } else if (matrix[l][r] < target) {
          r++
        } else {
          return true
        }
      }

      return false
    }

    // 11. 旋转数组的最小数字

    /**
   * @param {number[]} numbers
   * @return {number}
   */
    //二分
    var minArray = function (numbers) {
      let l = 0, r = numbers.length - 1

      while (l < r) {
        const mid = Math.floor((l + r) / 2)
        if (numbers[mid] > numbers[r]) {
          l = mid + 1
        } else if (numbers[mid] < numbers[r]) {
          r = mid
        } else {
          r--
        }
      }
      return numbers[l]
    }


    // 32 - I.从上到下打印二叉树
    /**
     * @param {TreeNode} root
     * @return {number[]}
     */
    var levelOrder = function (root) {
      if (!root) return []
      let queue = [root]
      let results = []

      while (queue.length) {
        let len = queue.length
        for (let i = 0; i < len; i++) {
          const node = queue.shift()
          results.push(node.val)
          node.left && queue.push(node.left)
          node.right && queue.push(node.right)
        }
      }
      return results
    }

    // 32 - II. 从上到下打印二叉树 II

    /**
   * @param {TreeNode} root
   * @return {number[][]}
   */
    var levelOrder = function (root) {
      if (!root) return []
      let queue = [root]
      let results = []

      while (queue.length) {
        let len = queue.length
        let result = []
        for (let i = 0; i < len; i++) {
          const node = queue.shift()
          result.push(node.val)
          node.left && queue.push(node.left)
          node.right && queue.push(node.right)
        }
        results.push(result)
      }
      return results
    }

    // 32 - III.从上到下打印二叉树 III
    /**
     * @param {TreeNode} root
     * @return {number[][]}
     */
    var levelOrder = function (root) {
      if (!root) return []
      let queue = [root]
      let results = []
      let dir = true

      while (queue.length) {
        let len = queue.length
        let result = []
        for (let i = 0; i < len; i++) {
          const node = queue.shift()
          dir ? result.push(node.val) : result.unshift(node.val)
          node.left && queue.push(node.left)
          node.right && queue.push(node.right)

        }
        dir = !dir
        results.push(result)
      }
      return results
    }

    //  27. 二叉树的镜像

    /**
   * @param {TreeNode} root
   * @return {TreeNode}
   */
    var mirrorTree = function (root) {
      if (!root) return null

      const left = mirrorTree(root.left)
      const right = mirrorTree(root.right)
      root.left = right
      root.right = left
      return root
    }
    var mirrorTree = function (root) {
      const dfs = (node) => {
        if (node) {
          [node.left, node.right] = [node.right, node.left]
          node.left && dfs(node.left)
          node.right && dfs(node.right)
        }
      }
      dfs(root)
      return root
    }

    // 28. 对称的二叉树
    //参考leetcode

    // 26. 树的子结构
    /**
   * @param {TreeNode} A
   * @param {TreeNode} B
   * @return {boolean}
   */
    //考虑dfs会匹配多次的情况，如果用单独的变量，会以最后一次为准
    //所以只能动态helper的结果获得true,只要有一次，全局都是true
    //QAQ
    var isSubStructure = function (A, B) {
      if (!B) return false
      const valB = B.val

      function dfs(node) {
        if (!node) return false
        if (node.val === valB && helper(node, B)) return true
        return dfs(node.left) || dfs(node.right)
      }

      function helper(nodeA, nodeB) {
        if (nodeA && nodeB) {
          if (nodeA.val !== nodeB.val) return false
          return helper(nodeA.left, nodeB.left) && helper(nodeA.right, nodeB.right)
        }
        if (!nodeA && nodeB) return false //只有左树没有，右树有才是false

        return true
      }
      return dfs(A)
    }

    // 10 - II.青蛙跳台阶问题
    /** 动规
     * @param {number} n
     * @return {number}
     */
    var numWays = function (n) {
      let dp = [1, 1, 2]

      for (let i = 3; i <= n; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007
      }
      return dp[n]
    }

    //  63. 股票的最大利润
    /**
     * @param {number[]} prices
     * @return {number}
     */
    var maxProfit = function (prices) {
      let dp = [0], min = prices[0], len = prices.length
      if (len === 0) return 0
      for (let i = 1; i < len; i++) {
        min = Math.min(min, prices[i])
        dp[i] = Math.max(prices[i] - min, dp[i - 1])
      }
      return dp[len - 1]
    }

    //  42. 连续子数组的最大和
    /**
   * @param {number[]} nums
   * @return {number}
   */
    var maxSubArray = function (nums) {
      let dp = [], len = nums.length
      dp[0] = nums[0]
      for (let i = 1; i < len; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])
      }

      return Math.max(...dp)
    }


    // 47. 礼物的最大价值
    /**
   * @param {number[][]} grid
   * @return {number}
   */
    var maxValue = function (grid) {
      let rowLen = grid[0].length, colLen = grid.length
      let dp = new Array(colLen + 1).fill(0).map(v => new Array(rowLen + 1).fill(0))

      for (let i = 1; i <= colLen; i++) {
        for (let j = 1; j <= rowLen; j++) {
          const curVal = grid[i - 1][j - 1]
          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + curVal
        }
      }

      return dp[colLen][rowLen]
    }

    // 46. 把数字翻译成字符串

    /**
   * @param {number} num
   * @return {number}
   */
    var translateNum = function (num) {
      let nums = num.toString()
      let n = nums.length
      let dp = new Array(n)
      dp[0] = 1
      for (var i = 1; i < n; i++) {
        if (nums[i - 1] == '2' && nums[i] < '6') {
          dp[i] = dp[i - 1] + (i > 2 ? dp[i - 2] : 1)
        }
        else if (nums[i - 1] == '1') {
          dp[i] = dp[i - 1] + (i > 2 ? dp[i - 2] : 1)
        } else {
          dp[i] = dp[i - 1]
        }
      }
      return dp[n - 1]
    }

    // 48. 最长不含重复字符的子字符串

    /**
   * @param {string} s
   * @return {number}
   */
    var lengthOfLongestSubstring = function (s) {
      let len = s.length, max = 0, l = 0, r = 0
      const set = new Set()

      while (r < len) {
        if (set.has(s[r])) {
          set.delete(s[l])
          l++
        } else {
          set.add(s[r])
          max = Math.max(max, r - l + 1)
          r++
        }
      }

      return max
    }

    // 52. 两个链表的第一个公共节点
    /**
   * @param {ListNode} headA
   * @param {ListNode} headB
   * @return {ListNode}
   */
    //链表公共节点之后的值全都是相等,且长度相同
    var getIntersectionNode = function (headA, headB) {
      const map = new Map()
      let node = headA
      while (node) {
        map.set(node, true)
        node = node.next
      }

      node = headB;
      while (node) {
        if (map.has(node)) return node
        node = node.next
      }
      return null
    }

    //浪漫相遇
    // 如果链表一样长且有交点，则第一次遍历就能找到交点，返回
    // 如果不一样长且有交点，则第二次遍历就能找到交点，返回
    // 如果没有交点，则第二次遍历结束都是null，遍历结束，返回null
    var getIntersectionNode = function (headA, headB) {
      let rootA = headA, rootB = headB

      while (rootA !== rootB) {
        rootA = rootA ? rootA.next : headB
        rootB = rootB ? rootB.next : headA
      }

      return rootA
    }

    // 21. 调整数组顺序使奇数位于偶数前面
    /**
   * @param {number[]} nums
   * @return {number[]}
   */
    var exchange = function (nums) {
      if (!nums || nums.length === 0) return nums
      let left = 0, right = nums.length - 1

      while (left !== right) {
        if (nums[left] % 2 === 0) {
          [nums[left], nums[right]] = [nums[right], nums[left]]
          right--
        } else {
          left++
        }
      }
      return nums
    }

    // 58 - I.翻转单词顺序
    /**
   * @param {string} s
   * @return {string}
   */
    var reverseWords = function (s) {
      s = s.trim().replace(/\s+/g, ' ').split(' ').reverse()
      return s.join(' ')

    }

    var reverseWords = function (s) {
      let arr = s.trim().replace(/\s+/g, ' ').split(' ')
      let l = 0;
      let r = arr.length - 1
      while (l < r) {
        [arr[l], arr[r]] = [arr[r], arr[l]]
        l++
        r--
      }
      return arr.join(' ')
    }

    // 12. 矩阵中的路径
    /**
     * @param {character[][]} board
     * @param {string} word
     * @return {boolean}
    */
   //超出时间限制 fack
    var exist = function (board, word) {
      let isboo = false, colLen = board.length, rowLen = board[0].length, wlen = word.length
      if (colLen === 0 && rowLen === 0) return

      const helper = (col, row, index,) => {
        if (row < 0 || col < 0 || row >= rowLen || col >= colLen || board[col][row] !== word[index]) return 
        if (index === wlen - 1) return isboo = true
        board[col][row]=''

        helper(col + 1, row, index+1)
        helper(col - 1, row, index+1)
        helper(col, row + 1, index+1)
        helper(col, row - 1, index+1)
        board[col][row] = word[index]
      }
      helper(0, 0, 0)

      for (let i = 0; i < colLen; i++) {
        for (let j = 0; j < rowLen; j++) {
          if (board[i][j] === word[0]) {
            helper(i, j, 0)
            if (isboo) return isboo
          }
        }
      }

      return isboo
    }








  </script>
</body>

</html>