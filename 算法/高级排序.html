<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>高级排序</title>
</head>

<body>
    <script>
        /*----------------------------------------------希尔排序 ------------------------------------------------*/
        //时间复杂度O(n log n)
        //空间复杂度O(1)
        //5为基数每次算出连中进行排序
        function shellSort(arr) {
            var len = arr.length,
                temp,
                gap = 1;
            console.time('希尔排序耗时:');
            while (gap < len / 5) { //动态定义间隔序列
                gap = gap * 5 + 1;
            }
            for (gap; gap > 0; gap = Math.floor(gap / 5)) {
                for (var i = gap; i < len; i++) {
                    temp = arr[i];
                    for (var j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {
                        arr[j + gap] = arr[j];
                    }
                    arr[j + gap] = temp;
                }
            }
            console.timeEnd('希尔排序耗时:');
            return arr;
        }
        var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
        console.log(shellSort(arr)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；

        /*----------------------------------------------归并排序 ------------------------------------------------*/
        //时间复杂度O(n log n)
        //空间复杂度O(n)
        //把数组划分为左右，然后运算，递归以上步骤，然后合并对比，保存一段，最后合并为一个总的。(在使用)
        //js并不适合太深的递归算法，所以用另一种方式实现较好
        //把数组划依次分为左右一小块，然后合并对比，保存一段，最后合并为一个总的。(未使用)
        function mergeSort(arr) { //采用自上而下的递归方法
            var len = arr.length;
            if (len < 2) {
                return arr;
            }
            var middle = Math.floor(len / 2),
                left = arr.slice(0, middle),
                right = arr.slice(middle);
            return merge(mergeSort(left), mergeSort(right));
        }

        function merge(left, right) {
            var result = [];
            console.time('归并排序耗时');
            while (left.length && right.length) {
                if (left[0] <= right[0]) {
                    result.push(left.shift()); //删除第一个并push
                } else {
                    result.push(right.shift());
                }
            }

            while (left.length) {
                result.push(left.shift());
            }
            while (right.length) {
                result.push(right.shift());
            }
            console.timeEnd('归并排序耗时');
            return result;
        }
        var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
        console.log(mergeSort(arr));

        /*----------------------------------------------快速排序 ------------------------------------------------*/
        //应该是最快的之一了
        //时间复杂度O(n log n)
        //空间复杂度O(log n)
        //以中间一个数为基数，分成左右，最大的排右边，无限执行此操作，最后剩余2个为一组，再合并数组
        //阮一峰的快速算法，暴涨了空间复杂度，是因为用了splice，增加了额外内存，直接用arr[n]取值即可。。


        //直观打印
        function qSort3(arr) {
            if (arr.length == 0) {
                return [];
            }
            var left = [];
            var right = [];
            var pivot = arr[0];
            for (var i = 1; i < arr.length; i++) {
                console.log(" 基准值：" + pivot + " 当前元素：" + arr[i]);
                if (arr[i] < pivot) {
                    console.log(" 移动 " + arr[i] + " 到左边 ");
                    left.push(arr[i]);
                } else {
                    console.log(" 移动 " + arr[i] + " 到右边 ");
                    right.push(arr[i]);
                }
            }
            return qSort3(left).concat(pivot, qSort3(right));
        }
        var a = [];
        for (var i = 0; i < 10; ++i) {
            a[i] = Math.floor((Math.random() * 100) + 1);
        }
        console.log(a);
        console.log();
        console.log(qSort3(a));
    </script>
</body>

</html>