<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>简单</title>
</head>

<body>
  <script>
    // 1.两数之和
    /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number[]}
   */

    var twoSum = function (nums, target) {
      const map = {}
      const len = nums.length
      for (let i = 0; i < len; i++) {
        const targetNum = target - nums[i];
        if (targetNum in map) return [map[targetNum], i]
        map[nums[i]] = i
      }
    };

    // console.log(twoSum([3, 3, 4,1, 2], 6))

    //7. 整数反转
    /**
   * @param {number} x
   * @return {number}
   */
    var reverse = function (x) {
      const max = Math.pow(2, 31) - 1;
      const min = -Math.pow(2, 31);
      const sign = Math.sign(x)
      const y = Math.abs(x).toString().split('').reverse().join('') * sign
      if ((y > max) || (y < min)) return 0
      return y
    };

    // console.log(reverse('123'))

    // 9. 回文数
    /**
 * @param {number} x
 * @return {boolean}
 */
    var isPalindrome = function (x) {
      var str = x.toString() || '';
      var str1 = str.split('').reverse();
      var str2 = str1.join('');
      if (str === str2) {
        return true
      } else {
        return false
      }
    };

    // console.log(isPalindrome('121'))

    //13. 罗马数字转整数
    var romanToInt = function (s) {
      const arr = s.split('');
      const obj = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
      }
      let result = arr.reduce((total, v, i, _arr) => {
        if (obj[v] < obj[_arr[i + 1]]) {
          return total - obj[v]
        }
        return total + obj[v]
      }, 0)
      return result
    };

    // console.log(romanToInt('IV'))

    //14. 最长公共前缀
    /**
   * @param {string[]} strs
   * @return {string}
   */
    var longestCommonPrefix = function (strs) {
      let minLength = 200
      let minStr = 200
      let result = ''
      strs.forEach((v, i) => {
        v.length < minLength && (minLength = v.length, minStr = v)
      })

      for (let i = 0; i < minStr.length; i++) {
        let boo = true
        for (let j = 0; j < strs.length; j++) {
          strs[j][i] !== minStr[i] && (boo = false)
        }

        if (boo) {
          result += minStr[i]
        } else {
          break;
        }
      }

      return result
    };
    // console.log(longestCommonPrefix(["reflower", "flow", "flight"]))

    //20. 有效的括号 

    /**  非常不稳定
 * @param {string} s
 * @return {boolean}
 */
    var isValid = function (s) {
      const cache = []
      const map = new Map()
      map.set("(", ")")
      map.set("[", "]")
      map.set("{", "}")
      for (let i = 0; i < s.length; i++) {
        if (map.has(s[i])) cache.push(s[i])
        else {
          if (cache.length === 0) return false
          if (map.get(cache[cache.length - 1]) === s[i]) cache.pop()
          else return false
        }
      }
      if (cache.length) return false
      return true
    };

    // 21. 合并两个有序链表
    /**
   * @param {ListNode} l1
   * @param {ListNode} l2
   * @return {ListNode}
   */
    function ListNode(val, next) {
      this.val = val
      this.next = next
    }

    var mergeTwoLists = function (l1, l2) {
      const linkedList = new ListNode();
      let pre = linkedList;

      while (l1 && l2) {
        if (l1.val >= l2.val) {
          pre.next = l2;
          l2 = l2.next;
        } else {
          pre.next = l1;
          l1 = l1.next;
        }
        pre = pre.next;
      }

      pre.next = l1 == null ? l2 : l1;

      return linkedList.next;
    }

    //26. 删除排序数组中的重复项
    /**
   * @param {number[]} nums
   * @return {number}
   */
    var removeDuplicates = function (nums) {
      for (let i = 0; i < nums.length; i++) {
        if (nums.indexOf(nums[i]) !== i) {
          nums.splice(i, 1);
          i = i - 1;
        }
      }
      return nums.length;
    };

    //27. 移除元素
    /**
   * @param {number[]} nums
   * @param {number} val
   * @return {number}
   */
    var removeElement = function (nums, val) {
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] === val) {
          nums.splice(i, 1);
          i = i - 1;
        }
      }
      return nums.length
    };

    //257. 二叉树的所有路径
    /**
   * @param {TreeNode} root
   * @return {string[]}
   */
    var binaryTreePaths = function (root) {
      let result = []
      let route = []
      const recursion = (root) => {
        if (!root) {
          return
        }
        route.push(root.val);
        if (!root.left && !root.right) {
          result.push(route.join('->'))
          route.pop()
          return
        }
        recursion(root.left)
        recursion(root.right)
        route.pop()
      }

      recursion(root)
      return result
    };

    // 617. 合并二叉树
    /**
 * @param {TreeNode} rooroot1
 * @param {TreeNode} rooroot2
 * @return {TreeNode}
 */
    var mergeTrees = function (root1, root2) {
      if (!root1 && root2) return root1 = root2
      if (!root1 && !root2) return null
      if (root1 && root2) root1.val += root2.val
      root1.left = mergeTrees(root1.left, root2 && root2.left)
      root1.right = mergeTrees(root1.right, root2 && root2.right)
      return root1
    };

    //225. 用队列实现栈
    var MyStack = function () {
      this.queue = [];
      this.prevNum = 0;  //当前队列中的元素数量
    };

    /**
     * Push element x onto stack. 
     * @param {number} x
     * @return {void}
     */
    MyStack.prototype.push = function (x) {
      let curr = 0;
      this.queue.push(x);
      while (curr < this.prevNum) {
        this.queue.push(this.queue.shift());
        curr++;
      };
      this.prevNum++;
    };

    /**
     * Removes the element on top of the stack and returns that element.
     * @return {number}
     */
    MyStack.prototype.pop = function () {
      if (this.prevNum > 0) {
        this.prevNum--;
        return this.queue.shift();
      };
    };

    /**
     * Get the top element.
     * @return {number}
     */
    MyStack.prototype.top = function () {
      return this.queue[0];
    };

    /**
     * Returns whether the stack is empty.
     * @return {boolean}
     */
    MyStack.prototype.empty = function () {
      return this.prevNum === 0;
    };

  </script>
</body>

</html>