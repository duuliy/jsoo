<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>简单</title>
</head>

<body>
  <script>
    // 1.两数之和
    /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number[]}
   */

    var twoSum = function (nums, target) {
      const map = {}
      const len = nums.length
      for (let i = 0; i < len; i++) {
        const targetNum = target - nums[i];
        const index = nums.indexOf(targetNum)
        if (index !== -1 && index !== i) return [index, i]
      }
    };

    // console.log(twoSum([3, 3, 4,1, 2], 6))

    //7. 整数反转
    /**
   * @param {number} x
   * @return {number}
   */
    var reverse = function (x) {
      const max = Math.pow(2, 31) - 1;
      const min = -Math.pow(2, 31);
      const sign = Math.sign(x)
      const y = Math.abs(x).toString().split('').reverse().join('') * sign
      if ((y > max) || (y < min)) return 0
      return y
    };

    // console.log(reverse('123'))

    // 9. 回文数
    /**
 * @param {number} str
 * @return {boolean}
 */
    function isPalindrome(str) {
      var len = str.length
      var middle = parseInt(len / 2)
      for (var i = 0; i < middle; i++) {
        if (str[i] != str[len - i - 1]) {
          return false
        }
      }
      return true
    }

    // console.log(isPalindrome('121'))

    //13. 罗马数字转整数
    var romanToInt = function (s) {
      const arr = s.split('');
      const obj = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
      }
      let result = arr.reduce((total, v, i, _arr) => {
        if (obj[v] < obj[_arr[i + 1]]) {
          return total - obj[v]
        }
        return total + obj[v]
      }, 0)
      return result
    };

    // console.log(romanToInt('IV'))

    //14. 最长公共前缀
    /**
   * @param {string[]} strs
   * @return {string}
   */
    var longestCommonPrefix = function (strs) {
      let minLength = 200
      let minStr = 200
      let result = ''
      strs.forEach((v, i) => {
        v.length < minLength && (minLength = v.length, minStr = v)
      })

      for (let i = 0; i < minStr.length; i++) {
        let boo = true
        for (let j = 0; j < strs.length; j++) {
          strs[j][i] !== minStr[i] && (boo = false)
        }

        if (boo) {
          result += minStr[i]
        } else {
          break;
        }
      }

      return result
    };
    // console.log(longestCommonPrefix(["reflower", "flow", "flight"]))

    //20. 有效的括号 

    /**  非常不稳定
 * @param {string} s
 * @return {boolean}
 */
    var isValid = function (s) {
      const cache = []
      const map = new Map()
      map.set("(", ")")
      map.set("[", "]")
      map.set("{", "}")
      for (let i = 0; i < s.length; i++) {
        if (map.has(s[i])) cache.push(s[i])
        else {
          if (cache.length === 0) return false
          if (map.get(cache[cache.length - 1]) === s[i]) cache.pop()
          else return false
        }
      }
      if (cache.length) return false
      return true
    };

    // 21. 合并两个有序链表
    /**
   * @param {ListNode} l1
   * @param {ListNode} l2
   * @return {ListNode}
   */
    function ListNode(val, next) {
      this.val = val
      this.next = next
    }

    var mergeTwoLists = function (l1, l2) {
      const linkedList = new ListNode();
      let pre = linkedList;

      while (l1 && l2) {
        if (l1.val >= l2.val) {
          pre.next = l2;
          l2 = l2.next;
        } else {
          pre.next = l1;
          l1 = l1.next;
        }
        pre = pre.next;
      }

      pre.next = l1 == null ? l2 : l1;

      return linkedList.next;
    }

    //26. 删除排序数组中的重复项
    /**
   * @param {number[]} nums
   * @return {number}
   */
    var removeDuplicates = function (nums) {
      for (let i = 0; i < nums.length; i++) {
        if (nums.indexOf(nums[i]) !== i) {
          nums.splice(i, 1);
          i = i - 1;
        }
      }
      return nums.length;
    };

    //27. 移除元素
    /**
   * @param {number[]} nums
   * @param {number} val
   * @return {number}
   */
    var removeElement = function (nums, val) {
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] === val) {
          nums.splice(i, 1);
          i = i - 1;
        }
      }
      return nums.length
    };

    //257. 二叉树的所有路径
    /**
   * @param {TreeNode} root
   * @return {string[]}
   */
    var binaryTreePaths = function (root) {
      let result = []
      let route = []
      const recursion = (root) => {
        if (!root) {
          return
        }
        route.push(root.val);
        if (!root.left && !root.right) {
          result.push(route.join('->'))
          route.pop()
          return
        }
        recursion(root.left)
        recursion(root.right)
        route.pop()
      }

      recursion(root)
      return result
    };

    // 617. 合并二叉树
    /**
 * @param {TreeNode} rooroot1
 * @param {TreeNode} rooroot2
 * @return {TreeNode}
 */
    var mergeTrees = function (root1, root2) {
      if (!root1 && root2) return root1 = root2
      if (!root1 && !root2) return null
      if (root1 && root2) root1.val += root2.val
      root1.left = mergeTrees(root1.left, root2 && root2.left)
      root1.right = mergeTrees(root1.right, root2 && root2.right)
      return root1
    };

    //225. 用队列实现栈
    var MyStack = function () {
      this.queue = [];
      this.prevNum = 0;  //当前队列中的元素数量
    };

    /**
     * Push element x onto stack. 
     * @param {number} x
     * @return {void}
     */
    MyStack.prototype.push = function (x) {
      let curr = 0;
      this.queue.push(x);
      while (curr < this.prevNum) {
        this.queue.push(this.queue.shift());
        curr++;
      };
      this.prevNum++;
    };

    /**
     * Removes the element on top of the stack and returns that element.
     * @return {number}
     */
    MyStack.prototype.pop = function () {
      if (this.prevNum > 0) {
        this.prevNum--;
        return this.queue.shift();
      };
    };

    /**
     * Get the top element.
     * @return {number}
     */
    MyStack.prototype.top = function () {
      return this.queue[0];
    };

    /**
     * Returns whether the stack is empty.
     * @return {boolean}
     */
    MyStack.prototype.empty = function () {
      return this.prevNum === 0;
    };


    // 746. 使用最小花费爬楼梯
    /** 动态规划
   * @param {number[]} cost
   * @return {number}
   */

    //  1. 0或1开始
    //  2.min(dp[i]+arr[i+1],dp[i]+arr[i+2])

    var minCostClimbingStairs = function (cost) {
      let dp = []
      let len = cost.length
      let i = 2
      dp[0] = dp[1] = 0;

      for (i; i <= len; i++) {
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
      }

      return dp[i - 1]
    }


    //53. 最大子序和  比一般的easy难

    /** 动态规划
 * @param {number[]} nums
 * @return {number}
 */

    // 新增这个数若比次数小，则丢弃之前的和。
    // 1.新增一个数
    // 2.若不新增，从这个数开始重新计数
    var maxSubArray = function (nums) {
      let dp = []
      const len = nums.length
      dp[0] = nums[0]

      let i = 1
      for (i; i < len; i++) {
        dp[i] = Math.max(nums[i], dp[i - 1] + nums[i])
      }

      // 关键点 ：dp  得到所有连续长串的值
      return Math.max(...dp)
    }

    // console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))

    function getMax(nums) {
      let max = -Infinity;
      for (let i = 0; i < nums.length; i++) {
        let sum = nums[i]
        max = Math.max(sum, max)
        for (let j = i + 1; j < nums.length; j++) {
          // 求连续子序列 往上加就行
          sum += nums[j];
          max = Math.max(sum, max)
        }
      }
      return max
    }


    // 121. 买卖股票的最佳时机

    /**
   * @param {number[]} prices
   * @return {number}
   */
    var maxProfit = function (prices) {
      let maxNum = 0
      for (let i = 0; i < prices.length; i++) {
        for (let j = i + 1; j < prices.length; j++) {
          maxNum = Math.max(maxNum, prices[j] - prices[i])
        }
      }
      return maxNum
    }

    var maxProfit = function (prices) {
      let min = Infinity, max = 0

      for (let i = 0; i < prices.length; i++) {
        const price = prices[i]
        min = Math.min(min, price)
        max = Math.max(max, price - min)
      }
      return max
    }

    var maxProfit = function (prices) {
      let len = prices.length
      let dp = new Array(len).fill(0)
      let min = prices[0]

      for (let i = 1; i < len; i++) {
        const price = prices[i]
        min = Math.min(min, price)
        dp[i] = Math.max(dp[i - 1], price - min)
      }

      return dp[len - 1]
    }

    // console.log(maxProfit([2, 9, 1, 4]))


    // 70. 爬楼梯

    /**
   * @param {number} n
   * @return {number}
   */

    //dp[1]=1
    //dp[2]=2
    //dp[3]=3
    //dp[4]=5

    var climbStairs = function (n) {
      let dp = []
      dp[1] = 1
      dp[2] = 2
      for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]
      }
      return dp[n]
    }

    // 122. 买卖股票的最佳时机 II

    /**  贪心
   * @param {number[]} prices
   * @return {number}
   */

    var maxProfit = function (prices) {
      let len = prices.length
      let max = 0
      for (let i = 1; i < len; i++) {
        max += Math.max(0, prices[i] - prices[i - 1])
      }
      return max
    }

    // 100. 相同的树
    /**
   * @param {TreeNode} p
   * @param {TreeNode} q
   * @return {boolean}
   */
    var isSameTree = function (p, q) {
      return JSON.stringify(p) === JSON.stringify(q)
    }

    var isSameTree = function (p, q) {
      if (!p && !q) return true
      if (!p || !q) return false
      if (p.val != q.val) return false
      return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }

    // 704. 二分查找

    /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number}
   */
    var search = function (nums, target) {
      return nums.indexOf(target)
    }

    var search = function (nums, target) {
      let left = 0
      let right = nums.length - 1
      while (left <= right) {
        let middleIndex = Math.floor((left + right) / 2)
        if (nums[middleIndex] === target) {
          return middleIndex
        }
        if (nums[middleIndex] < target) {
          left = middleIndex + 1
        }
        if (nums[middleIndex] > target) {
          right = middleIndex - 1
        }
      }
      return -1
    }

    // 283. 移动零

    /**
   * @param {number[]} nums
   * @return {void} Do not return anything, modify nums in-place instead.
   */
    var moveZeroes = function (nums) {
      let index = 0
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
          nums[index] = nums[i]
          index++
        }
      }

      return nums.fill(0, index)
    }

    // 88. 合并两个有序数组
    /**
   * @param {number[]} nums1
   * @param {number} m
   * @param {number[]} nums2
   * @param {number} n
   * @return {void} Do not return anything, modify nums1 in-place instead.
   */
    var merge = function (nums1, m, nums2, n) {
      // return nums1.filter(v=>v!==0).concat(nums2.filter(v => v !== 0)).sort()
      return [...nums1.filter(v => v !== 0), ...nums2.filter(v => v !== 0)].sort()
    }


    // 167. 两数之和 II - 输入有序数组
    /**
   * @param {number[]} numbers
   * @param {number} target
   * @return {number[]}
   */
    var twoSum = function (numbers, target) {
      debugger
      let left = 0
      let right = numbers.length - 1

      while (left < right) {
        const val = numbers[left] + numbers[right] - target
        if (val > 0) {
          right--
        } else if (val < 0) {
          left++
        } else {
          return [left + 1, right + 1]  //题目要求下标按1 开始
        }
      }
    }

    // 125. 验证回文串

    /**
   * @param {string} s
   * @return {boolean}
   */
    var isPalindrome = function (s) {
      s = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase()
      let left = 0
      let right = s.length - 1

      while(left< right){
        if(s[left]!==s[right]){
          return false
        }else{
          left++
          right--
        }
      }
      return true
    }





  </script>
</body>

</html>