<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 1.两数之和
    /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number[]}
   */

    var twoSum = function (nums, target) {
      const map = {}
      const len = nums.length
      for (let i = 0; i < len; i++) {
        const targetNum = target - nums[i];
        if (targetNum in map) return [map[targetNum], i]
        map[nums[i]] = i
      }
    };

    // console.log(twoSum([3, 3, 4,1, 2], 6))

    //7. 整数反转
    /**
   * @param {number} x
   * @return {number}
   */
    var reverse = function (x) {
      const max = Math.pow(2, 31) - 1;
      const min = -Math.pow(2, 31);
      const sign = Math.sign(x)
      const y = Math.abs(x).toString().split('').reverse().join('') * sign
      if ((y > max) || (y < min)) return 0
      return y
    };

    // console.log(reverse('123'))

    // 9. 回文数
    /**
 * @param {number} x
 * @return {boolean}
 */
    var isPalindrome = function (x) {
      var str = x.toString() || '';
      var str1 = str.split('').reverse();
      var str2 = str1.join('');
      if (str === str2) {
        return true
      } else {
        return false
      }
    };

    // console.log(isPalindrome('121'))

    // 144. 二叉树的前序遍历
    /**
   * @param {TreeNode} root
   * @return {number[]}
   */

    var preorderTraversal = function (root) {
      return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []
    };

    var preorderTraversal = function (root) {
      let result = [];
      let queue = [root];
      let node;
      while (node = queue.shift()) {
        result.push(node.val);

        node.right && queue.unshift(node.right);
        node.left && queue.unshift(node.left);
      }
      return result;
    };

    // 145. 二叉树的后序遍历
    /**
   * @param {TreeNode} root
   * @return {number[]}
   */
    var postorderTraversal = function (root) {
      return root ? [...postorderTraversal(root.left), ...postorderTraversal(root.right), root.val] : []
    };

    var postorderTraversal = function (root) {
      let result = [];
      let queue = [root];
      let node;
      while (node = queue.pop()) {
        result.unshift(node.val);

        node.left && queue.push(node.left);
        node.right && queue.push(node.right);

      }
      return result;
    };

    //13. 罗马数字转整数
    var romanToInt = function (s) {
      const arr = s.split('');
      const obj = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
      }
      let result = arr.reduce((total, v, i, _arr) => {
        if (obj[v] < obj[_arr[i + 1]]) {
          return total - obj[v]
        }
        return total + obj[v]
      }, 0)
      return result
    };

    // console.log(romanToInt('IV'))

    //14. 最长公共前缀
    /**
   * @param {string[]} strs
   * @return {string}
   */
    var longestCommonPrefix = function (strs) {
      let minLength = 200
      let minStr = 200
      let result = ''
      strs.forEach((v, i) => {
        v.length < minLength && (minLength = v.length, minStr = v)
      })

      for (let i = 0; i < minStr.length; i++) {
        let boo = true
        for (let j = 0; j < strs.length; j++) {
          strs[j][i] !== minStr[i] && (boo = false)
        }

        if (boo) {
          result += minStr[i]
        } else {
          break;
        }
      }

      return result
    };
    // console.log(longestCommonPrefix(["reflower", "flow", "flight"]))

    //20. 有效的括号 

    /**  非常不稳定
 * @param {string} s
 * @return {boolean}
 */
    var isValid = function (s) {
      const cache = []
      const map = new Map()
      map.set("(", ")")
      map.set("[", "]")
      map.set("{", "}")
      for (let i = 0; i < s.length; i++) {
        if (map.has(s[i])) cache.push(s[i])
        else {
          if (cache.length === 0) return false
          if (map.get(cache[cache.length - 1]) === s[i]) cache.pop()
          else return false
        }
      }
      if (cache.length) return false
      return true
    };



  </script>
</body>

</html>