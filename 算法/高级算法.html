<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>高级算法</title>
</head>

<body>
    <script>
        //斐波那契数列。效率极差。很多次递归被重复计算
        //0,1,1,2,3,5,8,13,21,34,55...
        const recurFib = n => {
            if (n < 2) {
                return n
            }
            return recurFib(n - 1) + recurFib(n - 2)
        }

        //综合选择排序 记录已计算过的 新算法
        //eg:1
        function dynFib(n) {
            var val = [];
            for (var i = 0; i <= n; ++i) {
                val[i] = 0;
            }
            if (n === 1 || n === 2) {
                return 1;
            } else {
                val[1] = 1;
                val[2] = 2;
                for (var i = 3; i <= n; ++i) {
                    val[i] = val[i - 1] + val[i - 2];
                }
                return val[n - 1];
            }
        }


        //eg:2  不使用数组的方式
        function iterFib(n) {
            var last = 1;
            var nextLast = 1;
            var result = 1;
            for (var i = 2; i < n; ++i) {
                result = last + nextLast;
                nextLast = last;
                last = result;
            }
            return result;
        }

        //贪心算法  
        // 最少硬币找零是给出要找零的钱数，以及可以用硬币的额度数量，找出有多少种找零方法。
        // 如：美国面额硬币有：1，5，10，25
        // 我们给36美分的零钱
        function MinCoinChange(coins) {
            var coins = coins;
            var cache = {};
            this.makeChange = function (amount) {
                var me = this;
                if (!amount) {
                    return [];
                };
                if (cache[amount]) {
                    return cache[amount];
                };
                var min = [], newMin, newAmount;
                for (var i = 0; i < coins.length; i++) {
                    var coin = coins[i];
                    newAmount = amount - coin;
                    if (newAmount >= 0) {
                        newMin = me.makeChange(newAmount);
                    };
                    if (newAmount >= 0 && (newMin.length < min.length - 1 || !min.length) && (newMin.length || !newAmount)) {
                        min = [coin].concat(newMin);
                    }
                };
                return (cache[amount] = min);
            };
        };

        var minCoinChange = new MinCoinChange([25, 20, 5, 1]);
        minCoinChange.makeChange(36)

        // 分治算法  实现大整数相加、相减  求指定整型数组的最大值和最小值。
        // 把数组分解到只有一个元素或者两个元素的时候，直接比大小返回，然后递归处理并返回结果。

        function divide_conquer(arr, from, to) {
            if (to - from === 1) {
                return { "max": Math.max(arr[from], arr[to]), "min": Math.min(arr[from], arr[to]) }
            } else if (to - from == 0) {
                return { "max": arr[from], "min": arr[to] }
            } else {
                var middle = parseInt(from + (to - from) / 2);
                var result1 = divide_conquer(arr, from, middle);
                var result2 = divide_conquer(arr, middle + 1, to);
                var result = {};
                if (result1["max"] > result2["max"]) {
                    result["max"] = result1["max"];
                } else {
                    result["max"] = result2["max"];
                }
                if (result1["min"] > result2["min"]) {
                    result["min"] = result2["min"];
                } else {
                    result["min"] = result1["min"];
                }
                return result;
            }


        }
        var arr = [34, 5, 6, 7111, 7, 8, 889, 9];
        console.log(divide_conquer(arr, 0, arr.length - 1));


        // 动态规划 
        // 名字多高端，就是利用条件优化算法。
        
        
        
        // 回溯法 相当于深度优先 最普遍的递归
        
        
        // 分支界限法  分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。
        // 1按照队列先进先出（FIFO）原则选取下一个结点为扩展结点。
        // 2按照优先队列中规定的优先级选取优先级最高的结点成为当前扩展结点。
    </script>
</body>

</html>