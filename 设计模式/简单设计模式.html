<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>
    <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

    <script>
        /*---------------------------------------------单例模式 ------------------------------------------------*/
        //单例模式 只能实例化一次的对象
        (function () {
            var unique;
            function Construct() {
                // ... 生成单例的构造函数的代码
                console.lof(999)
            }
            unique = new Constuct();
            return unique;
        })();
        /*----------------------------------------------观察者模式 ------------------------------------------------*/
        //也称 发布/订阅者模式
        //当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。
        //观察者模式本质上是一种对象行为模式，而 发布/订阅模式本质上是一种架构模式，强调组件的作用。
        //使用场景：当遇到一对多的时候可以使用观察者模式，比如vue中的watch  或一个data  多处显示  还有eventbus
        // 假如我们正在开发一个商城网站，网站里有header头部、nav导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用ajax异步请求获取用户的登录信息。这是很正常的，比如用户的名字和头像要显示在header模块里，而这两个字段都来自用户登录后返回的信息。这个时候，我们就可以把这几个模块的渲染事件都放到一个数组里面，然后待登录成功之后再遍历这个数组并且调用每一个方法。

        /*----------------------------------------------中介者模式 ------------------------------------------------*/
        //增加一个中介者对象后，所以的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。
        //就像react中redux或者dva统一管理数据流，或是统一管理utils或者api接口


        /*----------------------------------------------Prototype 模式 ------------------------------------------------*/
        //原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。

        /*----------------------------------------------Command(命令) 模式 ------------------------------------------------*/
        //将方案，请求，或操作封装到一个单一对象中，从而根据我们不同的请求对客户精心参数化和传递可供执行的方案调用。
        //说白就是把方法拆细一点，高内聚低耦合，然后调用

        /*----------------------------------------------Facade（外观） 模式 ------------------------------------------------*/
        //也可译为门面模式。它为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。引入外观角色之后，使用者只需要直接与外观角色交互，使用者与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。
        // 比如在家要看电影，需要打开音响，再打开投影仪，再打开播放器等等，引入外观角色之后，只需要调用“打开电影设备”方法就可以。外观角色封装了打开投影仪等操作，给使用者提供更容易使用的方法。
        //使用场景：在写聊天窗口时，调用注册和连接signalR接口，里面发送，接受，用户上下线（后台调用前端方法）等等都写在一个方法里面，并多次调用。。。

        /*----------------------------------------------工厂 模式 ------------------------------------------------*/
        //
        //汽车抽象类，当使用其实例对象的方法时会抛出错误
        var Car = function () { };
        Car.protorype = {
            getPrice: function () {
                return new Error('抽象方法不能调用！');
            },
            getSpeed: function () {
                return new Error('抽象方法不能调用！');
            }
        }

        /*----------------------------------------------Mixin 模式 ------------------------------------------------*/
        //任意一个对象的全部或部分属性拷贝到另一个对象上。
        //类似scss里面的@mixin 以及其他后台语言中的宏，也就是可以组合继承某些属性或方法。


        /*----------------------------------------------Decorator（装饰者） 模式 ------------------------------------------------*/
        //这样动态向对象添加职责的方式就是装饰者模式，就好比天冷了，我们穿上一层层衣服（注意一层层）
        var fire1 = plane.fire;
        var shot = function () {
            console.log('发射散弹');
        }
        plane.fire = function () {
            fire1();
            shot();
        }
        plane.fire();
        //发射子弹 发射散弹
        

        /*----------------------------------------------Flywight(享元) 模式 ------------------------------------------------*/
//一种性能优化的模式，通过共享公用数据来减少对象数量以达到优化程序的手段。

//可以理解为向函数传入不同参数，然后多次调用函数来构造新的函数


    </script>
</body>

</html>
