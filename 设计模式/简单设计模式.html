<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->
        
        <script>
            /*----------------------------------------------单例模式 ------------------------------------------------*/
        //单例模式 只能实例化一次的对象
        (function () {
            var unique;
            function Construct() {
                // ... 生成单例的构造函数的代码
                console.lof(999)
            }
            unique = new Constuct();
            return unique;
        })();
        /*----------------------------------------------观察者模式 ------------------------------------------------*/
        //也称 发布/订阅者模式
        //当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。
        //观察者模式本质上是一种对象行为模式，而 发布/订阅模式本质上是一种架构模式，强调组件的作用。
        //使用场景：当遇到一对多的时候可以使用观察者模式，比如vue中的watch  或一个data  多处显示
        // 假如我们正在开发一个商城网站，网站里有header头部、nav导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用ajax异步请求获取用户的登录信息。这是很正常的，比如用户的名字和头像要显示在header模块里，而这两个字段都来自用户登录后返回的信息。这个时候，我们就可以把这几个模块的渲染事件都放到一个数组里面，然后待登录成功之后再遍历这个数组并且调用每一个方法。

        /*----------------------------------------------中介者模式 ------------------------------------------------*/
        //增加一个中介者对象后，所以的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。
        //就像react中redux或者dva统一管理数据流，或是统一管理utils或者api接口


         /*----------------------------------------------Prototype 模式 ------------------------------------------------*/
         //原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。

         /*----------------------------------------------Command(命令) 模式 ------------------------------------------------*/
         //将方案，请求，或操作封装到一个单一对象中，从而根据我们不同的请求对客户精心参数化和传递可供执行的方案调用。
         //说白就是把方法拆细一点，高内聚低耦合，然后调用

         /*----------------------------------------------工厂 模式 ------------------------------------------------*/


         /*----------------------------------------------工厂 模式 ------------------------------------------------*/
         /*----------------------------------------------Mixin 模式 ------------------------------------------------*/
         /*----------------------------------------------Decorator（装饰者） 模式 ------------------------------------------------*/
         /*----------------------------------------------Flywight(享袁) 模式 ------------------------------------------------*/


        </script>
    </body>
</html>
