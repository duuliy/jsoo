<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>
    <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

    <script>
        //设计模式仅是用于指导一定程度方便维护或性能优化的代码设计思想，有一定启发作用。
        /*---------------------------------------------单例模式 ------------------------------------------------*/
        //单例模式 只能实例化一次的对象
        (function () {
            var unique;
            function Construct() {
                // ... 生成单例的构造函数的代码
                console.lof(999)
            }
            unique = new Constuct();
            return unique;
        })();
        /*----------------------------------------------观察者模式 ------------------------------------------------*/
        //当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，同步方式实现的。
        //观察者模式本质上是一种对象行为模式，而 发布/订阅模式本质上是一种架构模式，强调组件的作用。
        //使用场景：当遇到一对多的时候可以使用观察者模式，比如vue中的watch  或一个data  多处显示  还有eventbus
        // 假如我们正在开发一个商城网站，网站里有header头部、nav导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用ajax异步请求获取用户的登录信息。
        // 这是很正常的，比如用户的名字和头像要显示在header模块里，而这两个字段都来自用户登录后返回的信息。这个时候，我们就可以把这几个模块的渲染事件都放到一个数组里面，
        // 然后待登录成功之后再遍历这个数组并且调用每一个方法。
        
        /*----------------------------------------------发布/订阅者模式（本质上是一种架构模式） ------------------------------------------------*/
        //不同于观察者模式，是指一个发送者把消息发送到通道（消息队列），然后通过通道处理给订阅者，属于单向，异步实现。
        //与观察者区别：则是多了中间通道，观察者模式：发布者和订阅者属于松散耦合，而发布订阅的发布者和订阅者属于完全解耦合。
        //发布/订阅者模式更像是一种跨应用程序模式，而观察者是同应用程序下。
        //场景：微信订阅号

        /*----------------------------------------------中介者模式 ------------------------------------------------*/
        //增加一个中介者对象后，所以的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。
        //就像react中redux或者dva统一管理数据流，或是统一管理utils或者api接口


        /*----------------------------------------------Prototype 模式 ------------------------------------------------*/
        //原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。

        /*----------------------------------------------Command(命令) 模式 ------------------------------------------------*/
        //将方案，请求，或操作封装到一个单一对象中，从而根据我们不同的请求对客户精心参数化和传递可供执行的方案调用。

        /*----------------------------------------------策略模式 ------------------------------------------------*/
        //一个类的行为或其算法可以在运行时不同命令（策略）更改

        /*----------------------------------------------Facade（外观） 模式 ------------------------------------------------*/
        //也可译为门面模式。它为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。引入外观角色之后，使用者只需要直接与外观角色交互，使用者与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。
        // 比如在家要看电影，需要打开音响，再打开投影仪，再打开播放器等等，引入外观角色之后，只需要调用“打开电影设备”方法就可以。外观角色封装了打开投影仪等操作，给使用者提供更容易使用的方法。
        //使用场景：在写聊天窗口时，调用注册和连接signalR接口，里面发送，接受，用户上下线（后台调用前端方法）等等都写在一个方法里面，并多次调用。。。

        /*----------------------------------------------工厂 模式 ------------------------------------------------*/
        //不暴露对象创建的逻辑,而是将逻辑封装在一个函数对象内的模式。
        //汽车抽象类，当使用其实例对象的方法时会抛出错误
        var Car = function () { };
        Car.protorype = {
            getPrice: function () {
                return new Error('抽象方法不能调用！');
            },
            getSpeed: function () {
                return new Error('抽象方法不能调用！');
            }
        }

        /*----------------------------------------------Mixin 模式 ------------------------------------------------*/
        //任意一个对象的全部或部分属性拷贝到另一个对象上。
        //类似scss里面的@mixin 以及其他后台语言中的宏，也就是可以组合继承某些属性或方法。


        /*----------------------------------------------代理 模式 ------------------------------------------------*/
        //代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用、
        //指一个类别可以作为其它东西的接口

        /*----------------------------------------------Decorator（装饰者） 模式 ------------------------------------------------*/
        //这样动态向对象添加职责的方式就是装饰者模式，就好比天冷了，我们穿上一层层衣服（注意一层层）
        //在不改变原对象的基础上，通过对其进行包装扩展（添加属性或方法），使原有对象可以满足用户的更复杂需求。
        var fire1 = plane.fire;
        var shot = function () {
            console.log('发射散弹');
        }
        plane.fire = function () {
            fire1();
            shot();
        }
        plane.fire();
        //发射子弹 发射散弹
        

        /*----------------------------------------------Flywight(享元) 模式 ------------------------------------------------*/
//一种性能优化的模式，通过共享公用数据来减少对象数量以达到优化程序的手段。

//可以理解为向函数传入不同参数，然后多次调用函数来构造新的函数


    </script>
</body>

</html>
